<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8" />
    <title>Text Dash</title>
<style>
    .disable-select {
    -webkit-user-select: none;  
    -moz-user-select: none;    
    -ms-user-select: none;      
    user-select: none;
    }
    body {
        background-color: white;
        font-family: Consolas, courier, monospace;
        font-size: 16px;
    }
    .mid {
        text-align: center;
        margin-left: auto;
        margin-right: auto;
    }
    #container {
        position: relative; /* needed to make absolute positioning work inside (it positions from the closest positioned ancestor) */
        border: 1px solid black;
        width: max-content;
    }
    #game {
        text-align: left;
    }
    #triggerrow {
        display: block;
        border: 1px solid black;
        width: max-content;
    }
    .textlayer {
        display: inline-block;
        width: 0;
        height: 0;
    }
    #gameBackground {
        display: block;
        position: absolute;
        z-index: -10;
        background: white;
        isolation: isolate;
        width: max-content;
    }
    #gameForeground {
        display: block;
        position: absolute;
        z-index: 10;
        background: transparent;
        width: max-content;
    }
    .gametile {
        display: inline-block;
        background-color: transparent;
        z-index: 0;
    }
    #editorInterface {
        position: absolute;
        width: max-content;
    }
    .editortile {
        display: inline-block;
        background-color: transparent;
        color: transparent;
        position: relative;
        z-index: 9999;
    }
    .editortile, #triggerrow span {
        outline: 1px solid rgb(0 0 0 / 0.07);
    }
    .editortile:hover{
        outline: 2px solid rgb(0 0 0 / 0.5);
    }
    #triggerrow span:hover{
        outline: 4px solid rgb(0 0 0 / 0.5);
    }
    .dialog {
        text-align: center;
        border: 4px double black;
        display: block;
        position: relative;
        width: 32px;
        height: 32px;
    }
    .dialogsymbol {
        display: inline;
        margin: auto;
        vertical-align: middle;
    }
    .clickable:hover {
        text-decoration: underline;
        cursor: pointer;
    }
    table {
        border: 1px solid black;
        margin: auto;
    }
    tr {
        margin: 0;
    }
    td {
        border: 1px solid black;
        margin: 1px;
    }
    .scontainer {
        display: block;
    }
    .selector {
        position: relative;
        border: 2px solid black;
        padding: 1px 1px 1px 2px;
        display: flow-root;
        width: fit-content;
    }
    .expander {
        display: block;
        text-align: center;
        margin-left: 2px;
        border: 2px solid black;
        cursor: pointer;
        float: right;
        width: 19px;
    }
    .expander:hover {
        color: white;
        background-color: black;
    }
    .selectionoptions {
        position: absolute;
        display: flex;
        flex-direction: column;
        max-height: 120px;
        overflow: scroll;
        top: 24px;
        z-index: 10;
        background-color: white;
        border: 2px solid black;
        width: max-content;
        min-width: 30px;
        scrollbar-color: black white;
    }
    .selectionoption {
        border: 1px solid black;
        padding: 1px;
        cursor: pointer;
    }
    .selectionoption:hover {
        color: white;
        background-color: black;
    }
    .kys { /*trick to force certain elements to be 'inline' (this class is to be applied to tables)*/
        margin: auto;
        padding: 0;
        border: 0;
        vertical-align: middle;
    }
    input {
        background-color: white;
        font-family: Consolas, courier, monospace;
        font-size: 16px;
        border: 2px solid black;
        margin: 2px;
    }
    input:focus {
        color: white;
        background-color: black;
    }
    #charcontainer {
        border: 0;
    }
    #charcontainer tr {
        outline: 2px solid black;
    }
    #charcontainer tr td {
        border: 0;
    }
    #tvcontainer {
        display: block;
        min-height: 40px;
        width: max-content;
        min-width: 200px;
        border: 1px solid black;
    }
    #edittable{
        margin: 10px auto; 
    }
    #edittable tr td {
        padding: 2px;
    }
    #cttable {
        border: 2px solid black;
    }
    #cttable tr, #cttable tr td{
        margin: 1px;
        padding: 1px;
    }
    #cttable tr td:hover, #savedobjs tr td:hover{
        color: white;
        background-color: black !important;
        cursor: pointer;
    }
    #triggerrow .gametile{
        text-shadow: 1px 1px white, -1px 1px white, 1px -1px white, -1px -1px white;
    }
    .selected {
        outline: 2px solid rgb(0 255 255 / 0.35);
    }
    #savedobjpreview {
        outline: 2px solid black;
        position: absolute;
        display: none;
        background-color: white;
        z-index: 100;
    }
</style>
</head>
<body>
    <div class="mid">-=- Text Dash -=-</div>
    <div class="mid">Click or press space to jump.</div><br>

    <div class="mid" id="header">
        <span class="clickable" onclick="switchTab('main')">Main levels</span> | 
        <span class="clickable" onclick="switchTab('custom')">Custom levels</span> | 
        <span class="clickable" onclick="switchTab('edit')">Editor</span> | 
        <span class="clickable" onclick="switchTab('settings')">Settings</span>
    </div><br>

    <div class="mid" id="main">
        <div id="mainheader">Go to custom levels tab</div>
    </div>

    <div class="mid" id="custom">
        <div id="customheader"><span class="clickable" onclick="playLevel(0)">Play</span> | Exit</div>
    </div>

    <div class="mid" id="edit">
        <div id="editheader">Slot number: 0</div>
        <div>
            <span onmousedown="editorStates.velocity = -2000;" onmouseup="editorStates.velocity = 0;">&lt;&lt;</span>&nbsp;
            <span onmousedown="editorStates.velocity = -200;" onmouseup="editorStates.velocity = 0;">&lt;</span>&nbsp;
            <span>0/100</span>&nbsp;
            <span onmousedown="editorStates.velocity = 200;" onmouseup="editorStates.velocity = 0;">&gt;</span>&nbsp;
            <span onmousedown="editorStates.velocity = 2000;" onmouseup="editorStates.velocity = 0;">&gt;&gt;</span>
        </div>
    </div>

    <div class="mid" id="settings">
        <div id="settingsheader">Gameplay | Editor | Saving | Help</div>
    </div>

    <div id="container" class="mid">
        <div id="game" class="disable-select"></div>
    </div>

    <div id="practice" class="mid">
        <span id="practiceenter">Enter practic mode</span>
        <span id="practiceactive" style="display: none;">
            Exit prctice mode<br>
            Place checkpoint (x) | Remove checkpoint (c)
        </span>
    </div>

    <div id="editorunder">
        <div class="mid">- Triggers -</div>
        <div id="triggerrow" class="mid disable-select"></div>
        <div id="triggeroptions" class="mid">
            <table class="kys"><tr class="kys"><td class="kys">Target:</td>
                <td class="kys"><span id="target1"></span></td>
                <td class="kys">&nbsp;| Property:</td>
                <td class="kys"><span id="target2"></span> </td></tr></table>
            <div id="tvcontainer" class="mid"><span id="tvalue" style="display: none; margin: 5px;">
                <table class="kys"><tr class="kys"><td class="kys">Value: </td><td class="kys">
                    <span id="tvalue-color" style="display: none;">
                        <input type="color" name="tvcolor" id="tvcolor"/> Alpha <input type="number" name="tvcolora" id="tvcolora" min="0" max="1" step="0.01" size="6"/>
                    </span>
                    <span id="tvalue-number" style="display: none;">
                        <input type="number" name="tvnumber" id="tvnumber" step="1" size="7"/>
                    </span>
                    <span id="tvalue-numbera" style="display: none;">
                        <input type="number" name="tvnumbera" id="tvnumbera" min="0" max="360" step="1" size="6"/>
                    </span>
                    <span id="tvalue-numberp" style="display: none;">
                        <input type="number" name="tvnumberp" id="tvnumberp" min="0" max="24" step="1" size="6"/>
                    </span>
                    <span id="tvalue-number1" style="display: none;">
                        <input type="number" name="tvnumber1" id="tvnumber1" min="0" max="1" step="0.01" size="6"/>
                    </span>
                    <span id="tvalue-blend" style="display: none;">
                        <span id="tvblendx"></span>
                    </span>
                </td>
                <td class="kys">
                    &nbsp;| Duration: <input type="number" name="tlength" id="tlength" step="1" min="1" size="10"/> ms |&nbsp;
                </td>
                <td class="kys">
                    Offset: <input type="number" name="toffset" id="toffset" step="1" min="1" size="10"/> ms |&nbsp;
                </td>
                <td class="kys">
                    <span onclick="addTrigger(); " class="clickable">Submit</span>
                </td>
                </tr></table>
            </span></div>
        </div>
        <table id="edittable">
            <tr>
                <td id="editsaving">
                    <div class="mid">- Saving -</div>
                    <div>[<span id="filename">No file</span>]</div>
                    <label for="infile" class="clickable">Choose file</label>
                    <div class="clickable" onclick="navigator.clipboard.writeText(exportLevel());">Export file</div>
                    <input type="file" name="infile" id="infile" accept=".tdl" style="display: none;" onchange="
                    document.getElementById('filename').textContent = infile.files.length == 0 ? 'No file' : infile.files[0].name;
                    "/>
                    <div class="clickable" onclick="importLevel(infile.files[0])">Import file</div>
                    <div class="clickable" onclick="exportRaw()">Export JSON</div>
                    <div class="clickable" onclick="importRaw(window.prompt('Paste level string'))">Import JSON</div>
                </td>
                <td id="edittools">
                    <div class="mid">- Tools -</div>
                    <div>Set start position</div>
                    <div id="selectbtn" class="clickable" onclick="editorStates.mode = 'select';">Select</div>
                    <div id="selectoptions" style="display: none;">
                        <div class="clickable" onclick="editorStates.whatToAdd = editorStates.selectedTiles; syncTileRows();">Use as object</div>
                        <div class="clickable" onclick="fillSelecion()">Fill with object</div>
                        <div class="clickable" onclick="editorStates.hasSelection = false; document.getElementById('selectbtn').style.display = 'inline-block'; document.getElementById('selectoptions').style.display = 'none';">Deselect</div>
                        <div class="clickable" onclick="savingCustom=true, savingFromSelection=true">Save object</div>
                    </div>
                    <table id="savedobjs"></table>
                    <div class="clickable" onclick="savingCustom=true, savingFromSelection=false">Save object</div>
                    <div>Preview colors <input type="checkbox" name="previewcolors" id="previewcolors" checked="true"/></div>
                </td>
                <td id="chardialog">
                    <div class="mid">- Tile editor -</div>
                    <div id="singletile">
                        <div class="mid"><span onclick="goToTileRowPage(tileRowPage-1);" style="cursor: pointer;">&lt;&lt;</span> | <span onclick="goToTileRowPage(tileRowPage+1);" style="cursor: pointer;">&gt;&gt;</span></div>
                        <table id="charcontainer"></table>
                        <div class="mid">
                            <span class="clickable" onclick="addNewTileRow()">Add&nbsp;character</span> | 
                            <span class="clickable" onclick="removeTileRow()">Remove&nbsp;character</span>
                        </div>
                        <div class="mid">Start of oscillation:<input type="number" name="tiletimebase" id="tiletimebase" min="0" step="1" size="9" onchange="editorStates.tempTile.timeBase=Number(tiletimebase.value)"/></div>
                        <div class="mid clickable" onclick="editorStates.whatToAdd=[[editorStates.tempTile]]">Use tile</div>
                    </div>
                    <div id="multitile" class="mid" style="display: none;">
                        <div>Multiple tiles being<br>used as object.</div>
                        <br>
                        <div class="clickable" onclick="editorStates.whatToAdd=[[editorStates.whatToAdd[0][0]]]; syncTileRows()">Return to single mode</div>
                        <br>
                    </div>
                    <br>
                    <div> Delete mode <input type="checkbox" name="deletemode" id="deletemode"/></div>
                </td>
                <td id="chartable">
                    <div class="mid">- Character table -<br>
                    Click on a character to copy it.<br>
                    Characters with special gameplay effects are colored.</div>
                    <div class="mid">
                        <span onclick="chartablePage-=1; buildChartable(chartablePage)" style="cursor: pointer;">&lt;&lt;</span> 
                        <span id="ctrange"></span> 
                        <span onclick="chartablePage+=1; buildChartable(chartablePage)" style="cursor: pointer;">&gt;&gt;</span>
                    </div>
                </td>
            </tr>
        </table>
        <div id="savedobjpreview"></div>
    </div>
    <input type="text" id="tvblend" name="tvblend" style="display: none;"/><!--don't worry about this-->
<script>
var gameWidth = 25;
var gameHeight = 10;
var tileString = "";

///////////////////////////////
//       player stuff        //
///////////////////////////////

var player1 = {
    y: 3, ySub: 0, vy: 0, //y increases downward, n|1200 = n+1|0
    mode: 0, gravity: 1,
    bufferCheck: true, previousTile: false, previousY: 3,
    dashing: false, fallTimer: 6, flag1: false
};
var player2 = {
    y: 3, ySub: 0, vy: 0, //x and y values have subunits of 1/1200, the actual position is always rounded down
    mode: 0, gravity: -1,
    bufferCheck: true, previousTile: false, previousY: 3,
    dashing: false, fallTimer: 6, flag1: false
};
var commonStates = {
    height: 10, width: 100,
    x: 0, speed: 1, xSub: 0, frame: 0,
    colorMain: [0, 0, 0, 1], colorGlow: [0, 0, 0, 0],
    P2Active: false
}
var defaultPlayer = structuredClone(player1);
var defaultCommonStates = structuredClone(commonStates);
var speedValues = [100, 125, 160, 200, 240];
var playerIcons = ["X", "O", ">", "M", "U", "Đ", "R"] //cube, ball, wave, spider, ufo, line fly, robot
var gravityValues = [6, 5, 0, 6, 8, 0, 7];

var renderOffset = 0; //at the beginning and the end of a level, the player needs to slide in/out without the camera moving, this variable is used to control that 

/*  -- TILE DEFINITION --
    chars: string[n]            display characters in order of appearance
    times: int[n]               time each character is visible in ms
    timeBase: int               starting x position for oscillation
    behavior: string[n]         how each character intercats with the player (solid, semisolid, kill, none, default)
    colorGroup: int(1~9)[n]     number of the color to use for each character
    *for special objects to have their intended effect, behavior must be set to default
    
    -- TRIGGER OBJECT DEFINITION --
    target1: c1, c2, ..., c9, bg, fg, common
    target2: whatever that object may contain
    offset: delay before the transition (ms)
    time: duration of transition in frames (ms)
    trigger object:
    {(target1 as keys)]: {(target2 as keys): [(sparse array indexed by xpos) ...,[value, offset, time],...]}}
    + add a macro into the editor for creating multiple triggers at once that set the specified target1's properties to those defined in the style dialog
*/
var testTile = {
    chars: [],
    times: [],
    timeBase: 0,
    behavior: [],
    colorGroup: []
};
var emptyTriggerObject = {
    c1: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c2: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c3: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c4: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c5: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c6: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c7: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c8: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c9: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    bg: {c1: [], c2: [], gradAngle: [], grad1: [], grad2: []},
    fg: {c1: [], c2: [], gradAngle: [], grad1: [], grad2: [], blend: []},
    common: {playerColumn: []}
}; //this may look bad,
var defaultValues = {
    c1: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c2: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c3: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c4: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c5: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c6: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c7: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c8: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c9: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    bg: {c1: [255, 255, 255, 1], c2: [255, 255, 255, 1], gradAngle: 0, grad1: 0, grad2: 100},
    fg: {c1: [255, 255, 255, 0], c2: [255, 255, 255, 0], gradAngle: 0, grad1: 0, grad2: 100, blend: "normal"},
    common: {playerColumn: 5}
};
var currentValues = structuredClone(defaultValues);
var typeMap = {
    rgbaMain: "color", //rgba array
    rgbaGlow: "color",
    c1: "color",
    c2: "color",
    glowRadius: "number",
    glowOffsetX: "number",
    glowOffsetY: "number",
    playerColumn: "numberp", //integer
    gradAngle: "numbera", //angle (0~360)
    grad1: "number1", //0~1
    grad2: "number1",
    blend: "blend" //blend mode (string)
}
function arrayToRGB(a){
    return `rgb(${a[0]} ${a[1]} ${a[2]} / ${a[3]})`
}
function cton(c, a){ //color formatters 
	var d = [0, 0, 0];
	for (i = 0; i < 3; i++){
		d[i] = Number("0x" + c.substring(2*i+1,2*i+3));
	}
    if (typeof a === "number") {
        d.push(a); //we add alpha if it exists
    }
	return d;
}
function ntoc(n){ //destroys alpha cannel (it's only used for setting color selectors anyway)
    if (n.length = 4) {n.pop;}
	var o = "#";
	for (i = 0; i < 3; i++){
		o += n[i].toString(16).padStart(2, "0");
	}
	return o;
}
var level = { //this will always hold the level being played/edited, we load them into this from a JSON file (?)
    title: "default00",
    tiles: Array(10),
    triggers: structuredClone(emptyTriggerObject),
    width: 100,
    height: 10,
    initialState: [],
    speedChanges: [] //we want to keep track of this seperately to make trigger calculations easier [position, speed] (has to be sorted)
    //there must only be one speed chnage per column (unique x), if you try to add more than 1 then only the firts one applies
    //doing this also means that we have to disallow speed changes in mulistate tiles and also assume that every speed change is necessary
};
for (let i = 0; i < level.height; i++) {
    level.tiles[i] = new Array(100); //grr why does this have to be done
}
function clamp(a, min, max){ //goes throuh arrays recusively (???????)
    if (Array.isArray(a)){
        for (let i = 0; i < a.length; i++){
            a[i] = clamp(a[i], min, max);
        }
        return a
    }
    return Math.min(Math.max(a, min), max);
}
function exists(tile){
    if (!tile){return false}
    if (!(Object.keys(tile).includes("timeBase") && Object.keys(tile).includes("colorGroup") && Object.keys(tile).includes("behavior") && Object.keys(tile).includes("times") && Object.keys(tile).includes("chars"))){return false;} //my god...
    return tile.colorGroup.length != 0 && tile.chars.length != 0 && tile.times.length != 0 && tile.behavior.length != 0;
}
///////////////////////////////
//        rendering          //
///////////////////////////////
function computeTriggerValue(target1, target2, x, subx, frame){
    frame = frame || posToFrame(x, subx);
    var currentTriggers = level.triggers[target1][target2];
    var nextIndex = currentTriggers.findLastIndex((e,i) => Array.isArray(e) && (i <= x));
    var nextTrigger = nextIndex == -1 ? [defaultValues[target1][target2],1,0] : currentTriggers[nextIndex]; //value, duration, offset
    var currentIndex = currentTriggers.findLastIndex((e,i) => Array.isArray(e) && (i < nextIndex)); //this will be -1 if the trigger doesn't exist, in that case we use default values
    var currentTrigger = currentIndex == -1 ? [defaultValues[target1][target2],1,0] : currentTriggers[currentIndex];
    var interpolationValue = clamp((frame - posToFrame(nextIndex, 0) - nextTrigger[2])/nextTrigger[1], 0, 1);
    if (typeMap[target2] == "blend") {return nextTrigger[0];}
    if (typeMap[target2] == "color") {return Array(4).fill(1).map((a, b) => interpolationValue*nextTrigger[0][b] + (1-interpolationValue)*currentTrigger[0][b])}
    //it's a regular number otherwise
    return interpolationValue*nextTrigger[0] + (1-interpolationValue)*currentTrigger[0];
}
function stateAt(tile, frame){
    if (!tile || !tile.times) {return false}
    if (tile.times.length == 1) {return {char: tile.chars[0], behavior: tile.behavior[0], colorGroup: tile.colorGroup[0]}}
    frame -= posToFrame(tile.timeBase, 0);
    frame = (9999999 + frame) % tile.times.reduce((a, b) => a + b); //shitty fix for the shitty modulo of js
    var index = 0;
    var soFar = 0;
    while (soFar < frame){
        soFar += tile.times[index];
        index++;
    }
    return {char: tile.chars[index-1], behavior: tile.behavior[index-1], colorGroup: tile.colorGroup[index-1]};
}
function tilePropertyRelative(dx, dy, pl, pr){
    if (pl.y + dy*pl.gravity < 0 || pl.y + dy*pl.gravity >= level.height || commonStates.x + dx < 0 || commonStates.x + dx >= level.width){
        return false;
    }
    //returns the behavior of a tile by a position relative to the player (y coord. adjsted with gravity, down is positive)
    //use only for gameplay purposes
    var k = stateAt(level.tiles[pl.y + dy*pl.gravity][commonStates.x + dx], commonStates.frame);
    if (k.behavior == "default"){
        k.behavior = "none";
        if (solidTiles.includes(k.char)){k.behavior = "solid"}
        if (semisolidTiles.includes(k.char)){k.behavior = "semisolid"}
        if (deadlyTiles.includes(k.char)){k.behavior = "kill"}
        if (specialTiles.includes(k.char)){k.behavior = "default"}
    }
    return k && k[pr];
}
var currentRenderer = -42; //requestfanimationframe id, use this to cancel the animation frame
function render(){
    //this bit is only run when you're in the editor -- it is enough to update editor stuff on render
    if (currentTab == "edit"){
        editorStates.editorSubpixel += editorStates.velocity;
        var distance = Math.floor(editorStates.editorSubpixel/1200);
        editorStates.x = Math.max(0, editorStates.x + distance);
        editorStates.editorSubpixel -= 1200*distance;
    } 
    renderOffset = Math.max(commonStates.x - currentValues.common.playerColumn, 0);
    renderOffset = Math.min(renderOffset, level.width - gameWidth + currentValues.common.playerColumn - 1); //the -1 might not be needed, i just left like it -- check this later
    if (currentTab == "edit"){
        renderOffset = editorStates.x;
    }
    var renderFrame = currentTab == "edit" ? posToFrame(editorStates.x, editorStates.editorSubpixel) : commonStates.frame;
    //apply trigger effects (base off of frame number)
    for (var a of Object.keys(emptyTriggerObject)){
        for (var b of Object.keys(emptyTriggerObject[a])){
            currentValues[a][b] = computeTriggerValue(a, b, renderOffset, currentTab == "edit" ? 0 : commonStates.xSub, renderFrame);
        }
    }
    //render tiles
    for (let i = 0; i < gameHeight; i++){
        for (let j = 0; j < gameWidth; j++){
            if (exists(level.tiles[i][j+renderOffset])){
                var currentTile = stateAt(level.tiles[i][j+renderOffset], renderFrame);
                var currentElement = document.getElementById(`${i}x${j}`);
                var currentColor = currentValues[`c${currentTile.colorGroup}`];
                currentElement.textContent = currentTile.char;
                currentElement.style.color = arrayToRGB(currentColor.rgbaMain);
                currentElement.style.textShadow = `${currentColor.glowOffsetX}px ${currentColor.glowOffsetY}px ${currentColor.glowRadius}px ${arrayToRGB(currentColor.rgbaGlow)}`;
                currentElement.style.mixBlendMode = currentColor.blend;
            }
            else {
                document.getElementById(`${i}x${j}`).textContent = "\xa0"; //regular spaces may disappear so we use a non-breaking one instead to be sure
            }
            document.getElementById(`e${i}x${j}`).classList.remove("selected");
        }
    }
    //render player
    if (currentTab != "edit"){
        document.getElementById(`${player1.y - player1.gravity + (player1.ySub > 1000 ? player1.gravity : 0)}x${commonStates.x - renderOffset}`).textContent = playerIcons[player1.mode];
        if (commonStates.P2Active) {document.getElementById(`${player2.y - (player2.ySub > 200 ? 0 : player2.gravity)}x${commonStates.x - renderOffset}`).textContent = playerIcons[player2.mode];}
    }
    if (currentTab == "edit"){
        for (let i = 0; i < gameWidth; i++){
            //triggers
            var triggerElement = document.getElementById(`t${i}`);
            var thisTriggerValue = computeTriggerValue(editorStates.tempTrigger.target1, editorStates.tempTrigger.target2, renderOffset+i, 0, false);
            document.getElementById(`t${i}`).textContent = !!level.triggers[editorStates.tempTrigger.target1][editorStates.tempTrigger.target2][i+renderOffset] ? "O" : "\xa0";
            switch (typeMap[editorStates.tempTrigger.target2]){
                case "color":
                    triggerElement.style.backgroundColor = arrayToRGB(thisTriggerValue);
                    break;
                case "number":
                    drawLineGraphPart(triggerElement, thisTriggerValue/10 + 0.5);
                    break;
                case "numbera":
                    drawLineGraphPart(triggerElement, thisTriggerValue/360);
                    break;
                case "numberp":
                    drawLineGraphPart(triggerElement, thisTriggerValue/10);
                    break;
                case "number1":
                    drawLineGraphPart(triggerElement, thisTriggerValue);
                    break;
            }
            //selection
            if (editorStates.hasSelection){
                editorStates.selectedTiles = [];
                for (let i = editorStates.selection[0][0]; i <= editorStates.selection[1][0]; i++){
                    editorStates.selectedTiles.push([]);
                    for (let j = editorStates.selection[0][1]; j <= editorStates.selection[1][1]; j++){
                        if (i >= 0 && i < gameHeight && j-renderOffset >= 0 && j-renderOffset < gameWidth){
                            document.getElementById(`e${i}x${j-renderOffset}`).classList.add("selected");
                            editorStates.selectedTiles[i-editorStates.selection[0][0]].push(level.tiles[i][j]);
                        }
                    }
                }
            }
        }
        pressedKeys = [];
        releasedKeys  = [];
        mousePressed = false;
        mouseReleased = false;
    }
    //render bg
    var element = document.getElementById("gameBackground");
    var values = currentValues.bg;
    element.style.backgroundImage = `linear-gradient(${values.gradAngle}deg, ${arrayToRGB(values.c1)} ${values.grad1}%, ${arrayToRGB(values.c2)} ${values.grad2}%)`;
    element = document.getElementById("gameForeground");
    values = currentValues.fg;
    element.style.backgroundImage = `linear-gradient(${values.gradAngle}deg, ${arrayToRGB(values.c1)} ${values.grad1}%, ${arrayToRGB(values.c2)} ${values.grad2}%)`;
    element.style.mixBlendMode = values.blend;
    currentRenderer = window.requestAnimationFrame(render);
}
function drawLineGraphPart(target, ratio){
    target.style.backgroundImage = `linear-gradient(0deg, white ${ratio*100 - 4}%, black ${ratio*100}%, white ${ratio*100 + 4}%)`;
}
//gameplay

function physicsStep(pl){ //takes a player object (to allow for duals potentially)
    //y subunit always increases with gravity, and it is negated when gravity is flipped
    var vyTemp = pl.vy += gravityValues[pl.mode];
    vyTemp = Math.min(vyTemp, 250);
    var currentTile = tilePropertyRelative(0, 0, pl, "behavior");
    var neighboringTiles = []; 
    var neighboringSpecailCharacters = [];
    for (let i = -1; i < 2; i++){
        for (let j = -1; j < 2; j++){
            neighboringTiles.push(tilePropertyRelative(i, j, pl, "behavior"));
            if (tilePropertyRelative(i, j, pl, "behavior") == "default"){
                neighboringSpecailCharacters.push(tilePropertyRelative(i, j, pl, "char"));
            }
        }
    }
    var canHitHead = neighboringSpecailCharacters.includes("H") || pl.mode == 1; 
    var canWaveSlide = neighboringSpecailCharacters.includes("D");
    var tileBelow = tilePropertyRelative(0, 1, pl, "behavior");
    var tileAbove = tilePropertyRelative(0, -1, pl, "behavior");
    var tileFront = tilePropertyRelative(1, 0, pl, "behavior");
    var landedFlang = false;
    //collisions
    if (currentTile == "solid" && (pl.ySub < 250 || (pl.previousTile == false && (pl.y - pl.previousY)*pl.gravity > 0))){ //snap onto top when you clip slightly
        pl.y -= pl.gravity;
        pl.ySub = 1199;
    }
    if (tileBelow == "solid" && pl.ySub > 1150 && (pl.mode != 2 || (pl.mode == 2 && canWaveSlide))){ //snap onto block below for small distances
        vyTemp = 0;
        pl.ySub = 1199;
        landedFlang = true;
    }
    if (tileAbove == "solid" && pl.ySub < 1000 && !canHitHead){ //hitting head
        playLevel()
    }
    if (pl.y < 0 || pl.y >= gameHeight){ //falling out of the level
        playLevel()
    }
    if (deadlyTiles.includes(currentTile) || solidTiles.includes(currentTile)){ //crashing into something
        playLevel()
    }
    if (landedFlang){
        pl.fallTimer = 6;
    } else {
        pl.fallTimer--;
    }
    if (pl.falltimer > 0){
        landedFlang = true;
    }
    
    //special tile interaction
    if (neighboringSpecailCharacters.includes("0")){ //fix this
        commonStates.speed = 0;
    }
    if (neighboringSpecailCharacters.includes("1")){
        commonStates.speed = 1;
    }
    if (neighboringSpecailCharacters.includes("2")){
        commonStates.speed = 2;
    }
    if (neighboringSpecailCharacters.includes("3")){
        commonStates.speed = 3;
    }
    if (neighboringSpecailCharacters.includes("4")){
        commonStates.speed = 4;
    }
    if (neighboringSpecailCharacters.includes("5")){
        commonStates.speed = 5;
    }
    if (neighboringSpecailCharacters.includes("-") && pl.ySub > 800){
        vyTemp = -180;
    }
    if (neighboringSpecailCharacters.includes("=") && pl.ySub > 800){
        pl.gravity *= -1;
        pl.y += pl.gravity;
        pl.ySub = 1200 - pl.ySub;
        vyTemp = 180;
    }
    if (neighboringSpecailCharacters.includes(")")){
        if (pl.gravity == -1) {pl.y += pl.gravity;}
        pl.gravity = 1;
        pl.ySub = 1200 - pl.ySub;
    }
    if (neighboringSpecailCharacters.includes("[")){
        if (pl.gravity == 1) {pl.y += pl.gravity;}
        pl.gravity = -1;
        pl.y += pl.gravity;
        pl.ySub = 1200 - pl.ySub;
    }
    if (neighboringSpecailCharacters.includes("X")){
        pl.mode = 0;
    }
    if (neighboringSpecailCharacters.includes("O")){
        pl.mode = 1;
    }
    if (neighboringSpecailCharacters.includes(">")){
        pl.mode = 2;
    }
    if (neighboringSpecailCharacters.includes("M")){
        pl.mode = 3;
    }
    if (neighboringSpecailCharacters.includes("U")){
        pl.mode = 4;
    }
    if (neighboringSpecailCharacters.includes("Đ")){
        pl.mode = 5;
    }
    if (neighboringSpecailCharacters.includes("R")){
        pl.mode = 6;
    }

    //click/hold interaction
    if (mousePressed || (isMouseDown && pl.bufferCheck)){
        switch (pl.mode){ //cube, ball, wave, spider, ufo, ???
            case 0:
                if (landedFlang) {vyTemp = -150;}
                break;
            case 1:
                if (landedFlang){
                    pl.gravity *= -1;
                    pl.y += pl.gravity;
                    pl.ySub = 1200 - pl.ySub;
                }
                break;
            case 2:
                vyTemp = -pl.gravity*speedValues[pl.speed];
                break;
            case 3:
                if (landedFlang){
                    pl.gravity *= -1;
                    pl.ySub = 1199;
                    vyTemp = 0;
                    let dy = 0;
                    while (tilePropertyRelative(0, dy, "behavior") != "solid"){
                        dy += gravity;
                        if (pl.y+dy < 0 || pl.y+dy > gameHeight){
                            playLevel();
                        }
                    }
                    pl.y += dy-gravity; 
                }
                break;
            case 4:
                vyTemp = -120;
                break;
            case 5:
                break;
            case 6:
                if (landedFlang) {vyTemp = -120;}
                break;
        }
        //orb interaction
        if (neighboringSpecailCharacters.includes("Q") && pl.mode != 2){
            vyTemp = -150;
        }
        if (neighboringSpecailCharacters.includes("@")){
            pl.gravity *= -1;
            pl.y += pl.gravity;
            pl.ySub = 1200 - pl.ySub;
            if (pl.mode != 2) {vyTemp = 180;}
        }
        if (neighboringSpecailCharacters.includes("Ö")){
            pl.gravity *= -1;
            pl.y += pl.gravity;
            pl.ySub = 1200 - pl.ySub;
            if (pl.mode != 2) {vyTemp = -150;}
        }
        if (neighboringSpecailCharacters.includes("¤")){
            pl.gravity *= -1;
            pl.ySub = 1199;
            vyTemp = 0;
            let dy = 0;
            while (tilePropertyRelative(0, dy, "behavior") != "solid"){
                dy += gravity;
                if (pl.y+dy < 0 || pl.y+dy > gameHeight){
                    playLevel();
                }
            }
            pl.y += dy-gravity; 
        }
        pl.bufferCheck = false;
    }
    //release interaction
    if (mouseReleased){
        switch (pl.mode){ //cube, ball, wave, spider, ufo, ???
            case 0:
                break;
            case 1:
                break;
            case 2:
                break;
            case 3:
                break;
            case 4:
                break;
            case 5:
                break;
        }
        pl.bufferCheck = true;
    }
    //calculate velocities
    if (pl.mode == 2){ //wave speed is handled outside normal means
        vyTemp = gravity*speedValues[commonStates.speed] * (isMouseDown ? -1 : 1);
    }
    pl.vy = vyTemp; 
    pl.ySub += pl.vy;
    pl.previousY = pl.y;
    if (pl.ySub > 1200) {pl.ySub -= 1200; pl.y += pl.gravity}
    if (pl.ySub < 0) {pl.ySub += 1200; pl.y -= pl.gravity}
    //console.log(pl.y, " ",pl.ySub);
    pl.previousTile = currentTile;
}
function gameLoop(){
    physicsStep(player1);
    if (commonStates.P2Active) {physicsStep(player2)}
    commonStates.xSub += speedValues[commonStates.speed];
    if (commonStates.xSub > 1200) {commonStates.xSub -= 1200; commonStates.x += 1}
    if (commonStates.xSub < 0) {commonStates.xSub += 1200; commonStates.x -= 1}
    commonStates.frame += 1;
    pressedKeys = [];
    releasedKeys  = [];
    mousePressed = false;
    mouseReleased = false;
}
///////////////////////////////
//          editor           //
///////////////////////////////

var editorStates = {
    currentLevel: 0,
    x: 0,
    editorSubpixel: 0,
    velocity: 0,
    mode: "add", //add, select,...?
    colorDialogTarget: "undefined",
    tempColor: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    tempTile: structuredClone(testTile),
    tempTrigger: {target1: "c1", target2: "rgbaMain", value: null, offset: 0, duration: 0},
    triggerPosition: 0,
    numberDialogState: {value: 0, min: 0, max: 1, integer: false},
    whatToAdd: [[{}]], //2d tile array
    whatToOverwrite: {chars: [true], times: [true], timeBase: [true], behavior: [true], colorGroup: [true], stateNumber: [true]}, //add later
    hasSelection: false,
    selection: [[0, 0], [0, 0]], //top left x,y; bottom right x,y
    selectedTiles: [[{}]],
    startPosData: {} //player object
}
function posToFrame(x, subx){ //only used in editor previews ugh guys please appreciate this
    if (x < 0){return 0} //needed due to how triggers are calculated
    var result = 0;
    subx += x * 1200 //convert to pure subpixles
    var thisTriggerDistance = 42; //if the remaining subx is less than this we know that we finish before the next speed change
    if (level.speedChanges.length == 0) {
        return Math.floor(subx / speedValues[1]) //special case for a level with no speed changes
    } 
    else {
        thisTriggerDistance = (level.speedChanges[0][0]-1) * 1200;
        if (subx < thisTriggerDistance){
            return Math.floor(subx / speedValues[1]); //special case for first speed change (ends before it)
        }
        else {
            result = thisTriggerDistance / speedValues[1] // (doesn't end before)
            subx -= thisTriggerDistance;
        }
    }
    for (let i = 0; i < level.speedChanges.length-1; i++){
        thisTriggerDistance = level.speedChanges[i+1][0] - level.speedChanges[i][0];
        thisTriggerDistance *= 1200; //convert to subpixels
        var currentSpeed = speedValues[level.speedChanges[i][1]];
        if (subx < thisTriggerDistance){
            result += Math.floor(subx / currentSpeed);
            return result;
        }
        else {
            result += thisTriggerDistance / currentSpeed
            subx -= thisTriggerDistance;
        }
    }
    result += Math.floor(subx / speedValues[level.speedChanges[level.speedChanges.length-1][1]]);
    return result;
}
function removeNthElement(a, n){
    return a.slice(0, n).concat(a.slice(n+1, a.length));
}
function exportLevel(){
    var data = JSON.stringify(level);
    var dataArray = [...data];
    var characterArray = [];
    var decoderArray = [];
    for (d of dataArray){
        if (!characterArray.includes(d)){
            characterArray.push(d);
        }
    }
    var foundPairs = [];
    var nextValue = characterArray.length;
    dataArray = dataArray.map((x) => characterArray.indexOf(x));
    while (nextValue < 4000){ //12 bit encoding -> we have max 4096 characters, this is a bit less to make sure 
        //find best pair
        var pairs = dataArray.map((a, b, c) => `${c[b]}x${c[b+1]}`);
        pairs.pop();
        var occurences = {}
        for (p of pairs) {
            occurences[p] = occurences[p]+1 || 1;
        }
        var bestScore = Math.max(...Object.values(occurences));
        if (bestScore < 3){break;}
        var bestPair = Object.keys(occurences)[Object.values(occurences).indexOf(bestScore)];
        decoderArray.push(bestPair.split("x").map((j) => Number(j)));
        //combine entries
        for (let i = pairs.length-1; i>=0; i--){
            if (pairs[i] == bestPair){
                dataArray = removeNthElement(dataArray, i);
                dataArray[i] = nextValue;
                i -= 1;
            }
        }
        nextValue++;
    }
    //combine data
    characterArray = characterArray.map((x) => x.codePointAt(0).toString(16).padStart(4, "0"));
    dataArray = dataArray.map((x) => x.toString(16).padStart(3, "0"));
    decoderArray = decoderArray.flatMap((x) => [x[0].toString(16).padStart(3, "0"), x[1].toString(16).padStart(3, "0")]);
    var fullData = dataArray.join("") + "fff" + decoderArray.join("") + "fff" + characterArray.join("");
    if (fullData.length % 2 == 1) {fullData += "0"}
    var fullDataArray = [];
    //pack into 8bit array
    for (let i = 0; i < fullData.length; i+=2){
        fullDataArray.push(parseInt(fullData.substring(i, i+2), 16));
    }
    var exportArray = new Uint8Array(fullDataArray);
    var exportData = new Blob([exportArray]);
    //export
    var exportURL = URL.createObjectURL(exportData);
    var q = document.createElement("a");
    q.download = `${level.title}.tdl`;
    q.href = exportURL;
    q.click();
    URL.revokeObjectURL(exportURL);
}
function importLevel(x){
    x.arrayBuffer().then((data) => {
        var q = new Uint8Array(data);
        var dataString = "";
        for (d of q){
            dataString += d.toString(16).padStart(2, "0")
        }
        //recover arrays
        var pointer = 0;
        var dataArray = [];
        while (dataString.substring(pointer, pointer+3) != "fff"){
            dataArray.push(parseInt(dataString.substring(pointer, pointer+3), 16));
            pointer += 3;
        }
        pointer += 3;
        var decoderArray = [];
        while (dataString.substring(pointer, pointer+3) != "fff"){
            decoderArray.push([parseInt(dataString.substring(pointer, pointer+3), 16), parseInt(dataString.substring(pointer+3, pointer+6), 16)]);
            pointer += 6;
        }
        decoderArray.reverse() //??? just trust me
        pointer += 3;
        var characterArray = [];
        while (pointer < dataString.length){
            characterArray.push(parseInt(dataString.substring(pointer, pointer+4), 16));
            pointer += 4;
        }
        //decode data
        var nextValue = Math.max(...dataArray);
        for (e of decoderArray){
            dataArray = dataArray.flatMap((d) => d == nextValue ? e : d);
            nextValue--;
        }
        level = JSON.parse(dataArray.map((d) => String.fromCharCode(characterArray[d])).join(""));
    });
}
function exportRaw(){
    navigator.clipboard.writeText(JSON.stringify(level));
    window.alert("Copied to clipboard");
}
function importRaw(data){
    try {
        var tempLevel = JSON.parse(data);
        if (tempLevel){
            level = JSON.parse(data)
        }
        else {
            window.alert("Are you fucking stupid?");
        }
    } catch (ee) {
        window.alert(`Import error ${ee}`);
    }
}
function addTiles(y, x){
    changeEditorLength(Math.max(editorStates.whatToAdd.length + x, level.tiles[0].length));
    for (let i = 0; i < editorStates.whatToAdd.length; i++){
        for (let j = 0; j < editorStates.whatToAdd[0].length; j++){
            if (y+j >= 0 && x+i < level.tiles[0].length && exists(editorStates.whatToAdd[j][i])){ //temporary fix... replacement options to be added later, or never
                var thisTile = editorStates.whatToAdd[j][i];
                if (level.speedChanges.map(a => a[0]).indexOf(x+i) != -1 && level.speedChanges[level.speedChanges.map(a => a[0]).indexOf(x+i)][2] == y+j){ //remove (overwrite) speed changes
                    level.speedChanges = removeNthElement(level.speedChanges, level.speedChanges.map(a => a[0]).indexOf(x+i));
                }
                if (speedchangeTiles.includes(thisTile.chars[0]) && !level.speedChanges.map(a => a[0]).includes(x+i)){ //add speed changes
                    level.speedChanges.push([x+i, Number(thisTile.chars[0]), y+j]);
                    level.speedChanges.sort((a, b) => a[0] - b[0]); //must be sorted for thing to work properly
                }
                level.tiles[y+j][x+i] = structuredClone(thisTile);
            }
        }
    }
}
function changeEditorLength(newlen){
    newlen = clamp(newlen, 25, 4096); //arbitrary max level length
    if (level.tiles[0].length > newlen){
        //make smaller
        while (level.tiles[0].length > newlen){
            for (var tr of level.tiles){
                tr.pop();
            }
        }
    }
    else {
        //make larger
        while (level.tiles[0].length < newlen){
            for (var tr of level.tiles){
                tr.push(null);
            }
        }
    }
}
var firstSelect = true;
function selectTiles(x, y){
    if (firstSelect){
        editorStates.selection[0] = [x, y];
        firstSelect = false;
    }
    else {
        editorStates.selection[1] = [x, y];
        if (editorStates.selection[0][0] > editorStates.selection[1][0]){
            var c = editorStates.selection[0][0];
            editorStates.selection[0][0] = editorStates.selection[1][0];
            editorStates.selection[1][0] = c;
        }
        if (editorStates.selection[0][1] > editorStates.selection[1][1]){
            var cc = editorStates.selection[0][1];
            editorStates.selection[0][1] = editorStates.selection[1][1];
            editorStates.selection[1][1] = cc;
        } //fuck you
        editorStates.mode = "add";
        editorStates.hasSelection = true;
        firstSelect = true;
        editorStates.selectedTiles = [];
        for (let i = editorStates.selection[0][0]; i <= editorStates.selection[1][0]; i++){
            editorStates.selectedTiles.push([]);
            for (let j = editorStates.selection[0][0]; j <= editorStates.selection[1][0]; j++){
                editorStates.selectedTiles[i-editorStates.selection[0][0]].push(level.tiles[i][j]);
            }
        }
        document.getElementById("selectbtn").style.display = "none";
        document.getElementById("selectoptions").style.display = "inline-block";
    }
}
function fillSelecion(){
    var fillPattern = deletemode.checked ? [[null]] : editorStates.whatToAdd;
    for (let i = editorStates.selection[0][0]; i <= editorStates.selection[1][0]; i++){
            for (let j = editorStates.selection[0][1]; j <= editorStates.selection[1][1]; j++){
                level.tiles[i][j] = fillPattern[i % fillPattern.length][j % fillPattern[0].length]
            }
        }
}
var inLevel = false;
var levelLoopId;
function playLevel(level){
    window.cancelAnimationFrame(currentRenderer);
    clearInterval(levelLoopId);
        //loadLevel(level) wich would load the level in question from a file into the level object -- implement when needed
    if (inLevel == true){
        //this means we have died/restarted at least once, so we update stats
    }
    inLevel = true;
    //reset values
    player1 = defaultPlayer; //player 2 is always set when you go into a dual so no need to reset it
    commonStates = defaultCommonStates;
    render();
    levelLoopId = setInterval(gameLoop, 10);
}
function exitLevel(){
    window.cancelAnimationFrame(currentRenderer);
    clearInterval(levelLoopId);
    inLevel = false;
}


var savefile = {
    settings: {
        autoRetry: true,
        sex: false 
    },
    savedObjects: Array(16) 
};
///////////////////////////////
//     html constructors     //
///////////////////////////////
function makeFiller(){ //creates an empty element the same size as the game screen
    var q = ""
    for (let i = 0; i < gameWidth; i++){q += "&nbsp;"}
    for (let i = 0; i < gameHeight; i++){q += "<br>"}
    return q;
}
tileString += `<span id="gameBackground">${makeFiller()}</span><span id="gameForeground">${makeFiller()}</span>`;
tileString += "<span id='editorInterface'>";
for (let i = 0; i < gameHeight; i++){
    for (let j = 0; j < gameWidth; j++){
        tileString += `<span id="e${i}x${j}" class="editortile" onmouseenter="tileHoverHandler(${i},${j},false)" onclick="tileHoverHandler(${i},${j},true)">&nbsp;</span>`
    }
    tileString += "<br>"
}
tileString += "</span>"
tileString += "<span id='gameInterface'>";
for (let i = 0; i < gameHeight; i++){
    for (let j = 0; j < gameWidth; j++){
        tileString += `<span id="${i}x${j}" class="gametile">&nbsp;</span>`
    }
    tileString += "<br>"
}
tileString += "</span>"
document.getElementById("game").innerHTML = tileString;

var currentTab = "blablabla"
var tabs = {
    main: ["main", "container", "practice"],
    custom: ["custom", "container", "practice"],
    edit: ["edit", "container", "editorunder", "editorInterface"],
    settings: ["settings"]
};
var everyTab = ["main", "container", "custom", "practice", "edit", "editorunder", "settings", "editorInterface"]; //questionable
function switchTab(tabname){
    //what to do when switching FROM this tab
    switch (tabname){
        case "main":
            break;
        case "custom":
            break;
        case "edit":
            window.cancelAnimationFrame(currentRenderer);
            break;
        case "settings":
            break;
    }
    document.getElementById("game").classList.remove(currentTab);
    document.getElementById("game").classList.add(tabname);
    for (t of everyTab){
        document.getElementById(t).style.display = tabs[tabname].includes(t) ? "block" : "none";
    }
    currentTab = tabname;
    //what to do when switching TO this tab
    switch (tabname){
        case "main":
            break;
        case "custom":
            break;
        case "edit":
            render();
            break;
        case "settings":
            break;
    }
}
switchTab("main");
var selections = {}
function buildSelector(name, target, options, otherfn){ //otherfn is called when an option is selected (supply as string)
    selections[name] = options[0];
    document.getElementById(target).classList.add("selector");
    var result = `<span id="${name}-text">${options[0]}</span><span class="expander" onclick="document.getElementById('${name}-options').style.display='flex'">+</span>
                <span id="${name}-options" class="selectionoptions" style="display:none">`
        for (let i = 0; i < options.length; i++){
            result += `<span class="selectionoption" onclick="document.getElementById('${name}-options').style.display='none';
                    document.getElementById('${name}-text').textContent='${options[i]}';
                    selections['${name}']='${options[i]}';${otherfn}">${options[i]}</span><br>`;
        }
    result += `</span>`;
    document.getElementById(target).innerHTML = result; //html has selection menus built in ... but im quirky like that
}
function destroySelector(name){
    selections["name"] = null;
}
var blendModes = ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
function syncSelectors(){
    for (const s of selections){
        document.getElementById(`${s}-text`).textContent = selections[s];
    }
}
var tileRowPage = 0;
var tileRowsPerPage = 3;
var activeTileRows = 0;
function addNewTileRow(){
    activeTileRows++;
    editorStates.tempTile.chars.push("");
    editorStates.tempTile.times.push(0);
    editorStates.tempTile.colorGroup.push(1);
    editorStates.tempTile.behavior.push("default");
    var characterContainer = document.getElementById("charcontainer");
    var addingIndex = characterContainer.childElementCount;
    var currentRow = characterContainer.appendChild(document.createElement("tr"));
    currentRow.id = `tilerow${addingIndex}`;
    currentRow.innerHTML = `<td class="tile-char"><input type="text" name="ttext${addingIndex}" id="ttext${addingIndex}" minlength="1" maxlength="1" size="1" onchange="editorStates.tempTile.chars[${addingIndex}] = ttext${addingIndex}.value" /></td>
                            <td class="tile-color"><span id="colselect${addingIndex}"></span></td>
                            <td class="tile-length"><input type="number" name="tlength${addingIndex}" id="tlength${addingIndex}" size="10" onchange="editorStates.tempTile.times[${addingIndex}] = Number(tlength${addingIndex}.value)" /></td>
                            <td class="tile-behavior"><span id="behaviorselect${addingIndex}"></span></td>`;
    buildSelector(`tcolor${addingIndex}`, `colselect${addingIndex}`, [1,2,3,4,5,6,7,8,9], `editorStates.tempTile.colorGroup[${addingIndex}] = Number(selections.tcolor${addingIndex})`);
    buildSelector(`tbehavior${addingIndex}`, `behaviorselect${addingIndex}`, ["solid", "semisolid", "kill", "none", "default"], `editorStates.tempTile.behavior[${addingIndex}] = selections.tbehavior${addingIndex}`);
    goToTileRowPage(tileRowPage);
}
function removeTileRow(){
    if (!document.getElementById("charcontainer").hasChildNodes()){return true;} //check if there is already nothing there
    if (document.getElementById("charcontainer").childElementCount == tileRowPage * tileRowsPerPage + 1){tileRowPage--;}
    activeTileRows--;
    document.getElementById("charcontainer").lastElementChild.remove();
    editorStates.tempTile.chars.pop();
    editorStates.tempTile.times.pop();
    editorStates.tempTile.colorGroup.pop();
    editorStates.tempTile.behavior.pop();
    goToTileRowPage(tileRowPage);
}
function syncTileRows(){
    //used when loading a tile(s) into the tile editor
    if (editorStates.whatToAdd.length == 1 && editorStates.whatToAdd[0].length == 1){ //one tile being loaded, make rows
        document.getElementById("singletile").style.display = "inline-block";
        document.getElementById("multitile").style.display = "none";
        var selectedTile = editorStates.whatToAdd[0][0];
        //adjust row number
        while (activeTileRows < selectedTile.chars.length){
            addNewTileRow();
        }
        while (activeTileRows > selectedTile.chars.length){
            removeTileRow();
        }
        //load data
        for (let i = 0; i < activeTileRows; i++){
            document.getElementById(`ttext${i}`).value = selectedTile.chars[i];
            document.getElementById(`tlength${i}`).value = selectedTile.times[i];
            selections[`tcolor${i}`] = selectedTile.colorGroup[i];
            selections[`tbehavior${i}`] = selectedTile.behavior[i];
        }
        syncSelectors();
    }
    else { //multile tiles being loaded, use multiple selection dialog
        document.getElementById("singletile").style.display = "none";
        document.getElementById("multitile").style.display = "inline-block";
    }
}
function goToTileRowPage(page){
    if (page < 0) {return;}
    var totalRows = document.getElementById("charcontainer").childElementCount;
    if (totalRows <= page * tileRowsPerPage){return;}
    tileRowPage = page;
    for (let i = 0; i < totalRows; i++){
        document.getElementById(`tilerow${i}`).style.display = "none";
        if (i >= page * tileRowsPerPage && i < totalRows && i < (page+1) * tileRowsPerPage) {
            document.getElementById(`tilerow${i}`).style.display = "table-row";
        }
    }
}
//maybe make a custom color selector too?

//trigger row
tileString = "";
for (let i = 0; i < gameWidth; i++){
    tileString += `<span id="t${i}" class="gametile" onclick="openTriggerMenu(${i})">&nbsp;</span>`;
}
document.getElementById("triggerrow").innerHTML = tileString;
buildSelector("ttarget1", "target1", Object.keys(defaultValues), "buildSelector('ttarget2', 'target2', Object.keys(emptyTriggerObject[selections.ttarget1]), 'editorStates.tempTrigger.target2 = selections.ttarget2'); editorStates.tempTrigger.target1 = selections.ttarget1; editorStates.tempTrigger.target2 = Object.keys(emptyTriggerObject[selections.ttarget1])[0];");
buildSelector("tvblendx", "tvblendx", blendModes, "tvblend.value = selections.tvblendx"); //silly workaround
function openTriggerMenu(pos){
    document.getElementById("tvalue").style.display = "block";
    document.getElementById(`tvalue-${typeMap[editorStates.tempTrigger.target2]}`).style.display = "inline";
    editorStates.triggerPosition = pos;
}
function addTrigger(){
    var triggerValue = document.getElementById(`tv${typeMap[selections.ttarget2]}`).value;
    switch (typeMap[selections.ttarget2]){
        case "color":
            triggerValue = cton(triggerValue, Number(tvcolora.value));
            break;
        case "number": case "numbera": case "numberp": case "number1":
            triggerValue = Number(triggerValue);
    }
    level.triggers[selections.ttarget1][selections.ttarget2][editorStates.x + editorStates.triggerPosition] = [triggerValue, Number(tlength.value), Number(toffset.value)]; //i hope this is all cloned
    //also close the trigger menu
    document.getElementById("tvalue").style.display = "none";
    document.getElementById(`tvalue-${typeMap[selections.ttarget2]}`).style.display = "none"; //breaks if you change the target2 while the menu is open
}

var tableElement = document.getElementById("chartable").appendChild(document.createElement("table"));
tableElement.id = "cttable";
for (let i = 0; i < 4; i++){
    var currentRow = tableElement.appendChild(document.createElement("tr"));
    for (let j = 0; j < 32; j++){
        var currentElement = currentRow.appendChild(document.createElement("td"));
        currentElement.id = `ct${i}x${j}`;
        currentElement.addEventListener("click", () => navigator.clipboard.writeText(String.fromCharCode(chartablePage*128 + i*32 + j)))
    } 
}
var deadlyTiles = ["A", "V", "Ж"];
var solidTiles = ["#", "Z", "Ш"];
var semisolidTiles = ["T"];
var specialTiles = ["@", "Ö", "¤", "÷", "-", "=", "~", "Q", ")", "[", "0", "1", "2", "3", "4", "D", "H", "X", "O", ">", "M", "U", "Đ", "R"];
var speedchangeTiles = ["0", "1", "2", "3", "4"];
function buildChartable(page){
    document.getElementById("ctrange").textContent = `${(page*128).toString(16)}-${(page*128 + 127).toString(16)}`
    for (let i = 0; i < 4; i++){
        for (let j = 0; j < 32; j++){
            var currentElement = document.getElementById(`ct${i}x${j}`);
            var char = String.fromCharCode(page*128 + i*32 + j);
            currentElement.textContent = char;
            currentElement.style.backgroundColor = "#FFFFFF";
            if (deadlyTiles.includes(char)){
                currentElement.style.backgroundColor = "#FF6060";
            }
            if (solidTiles.includes(char)){
                currentElement.style.backgroundColor = "#B0B0B0";
            }
            if (semisolidTiles.includes(char)){
                currentElement.style.backgroundColor = "#A0A0F0";
            }
            if (specialTiles.includes(char)){
                currentElement.style.backgroundColor = "#00FFFF";
            }
        } 
    } 
}
var chartablePage = 0;
buildChartable(0);
var savingCustom = false;
var savingFromSelection = false;
var killyourself = 1;
for (let i = 0; i < 2; i++){
    var r = document.getElementById("savedobjs").appendChild(document.createElement("tr"));
    for (let j = 0; j < 8; j++){
        var c = r.appendChild(document.createElement("td"));
        c.textContent = String.fromCharCode(65 + j + 8*i); //uppercase letters
        c.addEventListener("click", () => {
            if (!savingCustom){
                editorStates.whatToAdd = savefile.savedObjects[j + 8*i];
            }
            else if (savingFromSelection){
                savefile.savedObjects[j + 8*i] = editorStates.selectedTiles;
                savingCustom = false;
            }
            else {
                savefile.savedObjects[j + 8*i] = editorStates.whatToAdd;
                savingCustom = false;
            }
        });
        c.addEventListener("mouseenter", () => {
            //create tiles
            var instring = "";
            if (!savefile.savedObjects[j + 8*i]) {return;}
            for (var u of savefile.savedObjects[j + 8*i]){
                for (var v of u){
                    instring += (v && exists(v)) ? `<span style="color: ${noprevColors[v.colorGroup[0]]}">${v.chars[0]}</span>` : "&nbsp;";
                }
                instring += "<br>"
            }
            document.getElementById("savedobjpreview").innerHTML = instring;
            document.getElementById("savedobjpreview").style.display = "block";
        });
        c.addEventListener("mouseleave", () => {
            document.getElementById("savedobjpreview").style.display = "none";
        });
    }
}
var noprevColors = [null, "rgb(255 0 0)", "rgb(255 156 0)", "rgb(255 255 0)", "rgb(131 255 0)", "rgb(0 255 131)", "rgb(0 190 255)", "rgb(0 0 255)", "rgb(187 0 255)", "rgb(255 0 212)"];
///////////////////////////////
//      handling stuff       //
///////////////////////////////

function tileHoverHandler(x, y, press){ //x and y are display coords, press is true when this is called from a click (false when called from hover)
    y += editorStates.x;
    if (currentTab == "edit" && (isMouseDown || press)){
        switch (editorStates.mode) {
            case "add":
                if (deletemode.checked) {
                    level.tiles[x][y] = null;
                    if (level.speedChanges.map(a => a[0]).indexOf(y) != -1 && level.speedChanges[level.speedChanges.map(a => a[0]).indexOf(y)][2] == x){ //remove (overwrite) speed changes
                        level.speedChanges = removeNthElement(level.speedChanges, level.speedChanges.map(a => a[0]).indexOf(y));
                    }
                } 
                else {
                    addTiles(x, y);
                }
                break;
            case "select":
                if (press){
                    selectTiles(x, y);
                }
                break;
        }
    }
}

var pressedKeys = [];
var heldKeys = [];
var releasedKeys = [];
document.addEventListener("keydown", function(e){
    pressedKeys.push(e.key); //cleared on every logic frame
    heldKeys.push(e.key);
});
document.addEventListener("keyup", function(e){
    releasedKeys.push(e.key); //cleared on every logic frame
    heldKeys = heldKeys.filter(x => x != e.key); //removes the key in question from the array
});

var isMouseDown = false;
var mousePressed = false;
var mouseReleased = false;
document.addEventListener("mousedown", function(e){
    isMouseDown = true;
    mousePressed = true; //cleared on every logic frame
});
document.addEventListener("mouseup", function(e){
    isMouseDown = false;
    mouseReleased = true //cleared on every logic frame
});
document.addEventListener("mousemove", function(e){
    document.getElementById("savedobjpreview").style.top = `${e.y}px`;
    document.getElementById("savedobjpreview").style.left = `${e.x}px`;
});
</script>
</html>
