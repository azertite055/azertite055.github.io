<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8" />
    <title>Text Dash</title>
<style>
    * { box-sizing: border-box; min-width: 0; min-height: 0; } /* does this even fix anything? */
    .disable-select {
    -webkit-user-select: none;  
    -moz-user-select: none;    
    -ms-user-select: none;      
    user-select: none;
    }
    body {
        background-color: white;
        font-family: Consolas, courier, monospace;
        font-size: 16px;
    }
    .mid {
        text-align: center;
        margin-left: auto;
        margin-right: auto;
    }
    #container {
        position: relative; /* needed to make absolute positioning work inside (it positions from the closest positioned ancestor) */
        border: 1px solid black;
        width: max-content;
        overflow: hidden;
    }
    #game {
        text-align: left;
        position: relative;
    }
    #triggerrow {
        display: block;
        border: 1px solid black;
        width: max-content;
    }
    .textlayer {
        display: inline-block;
        width: 0;
        height: 0;
    }
    #gameBackground {
        display: block;
        position: absolute;
        z-index: -10;
        background: white;
        isolation: isolate;
        width: max-content;
    }
    #gameForeground {
        display: block;
        position: absolute;
        z-index: 10;
        background: transparent;
        width: max-content;
    }
    .gametilecontainer, .gametile {
        position: relative;
        display: inline-block;
        z-index: 0;
        background-color: transparent;
    }
    #game .gametile {
        position: absolute;
    }
    #cttable .gametile {
        position: absolute;
        background-color: transparent;
    }
    #editorInterface {
        position: absolute;
        width: max-content;
    }
    .editortile {
        display: inline-block;
        background-color: transparent;
        color: transparent;
        position: relative;
        z-index: 9999;
    }
    .editortile, #triggerrow span {
        outline: 1px solid rgb(0 0 0 / 0.07);
    }
    .editortile:hover{
        outline: 2px solid rgb(0 0 0 / 0.5);
    }
    #triggerrow span:hover{
        outline: 4px solid rgb(0 0 0 / 0.5);
    }
    .dialog {
        text-align: center;
        border: 4px double black;
        display: block;
        position: relative;
        width: 32px;
        height: 32px;
    }
    .dialogsymbol {
        display: inline;
        margin: auto;
        vertical-align: middle;
    }
    .clickable:hover {
        text-decoration: underline;
        cursor: pointer;
    }
    table {
        border: 1px solid black;
        margin: auto;
    }
    tr {
        margin: 0;
    }
    td {
        border: 1px solid black;
        margin: 1px;
    }
    .scontainer {
        display: block;
    }
    .selector {
        position: relative;
        border: 2px solid black;
        padding: 1px 1px 1px 2px;
        display: flow-root;
        width: fit-content;
    }
    .expander {
        display: block;
        text-align: center;
        margin-left: 2px;
        border: 2px solid black;
        cursor: pointer;
        float: right;
        width: 19px;
    }
    .expander:hover {
        color: white;
        background-color: black;
    }
    .selectionoptions {
        position: absolute;
        display: flex;
        flex-direction: column;
        max-height: 120px;
        overflow: scroll;
        top: 24px;
        z-index: 10;
        background-color: white;
        border: 2px solid black;
        width: max-content;
        min-width: 30px;
        scrollbar-color: black white;
        text-align: left;
        z-index: 10000;
    }
    .selectionoption {
        border: 1px solid black;
        padding: 1px;
        cursor: pointer;
        min-height: 1.2lh;
        z-index: 10000;
        margin-bottom: -1lh;
    }
    .ff-fix{
        margin-bottom: 0 !important;
    }
    .selectionoption:hover {
        color: white;
        background-color: black;
    }
    .kys { /*trick to force certain elements to be '"inline"' (this class is to be applied to tables)*/
        margin: auto;
        padding: 0;
        border: 0;
        vertical-align: middle;
    }
    input {
        background-color: white;
        font-family: Consolas, courier, monospace;
        font-size: 16px;
        border: 2px solid black;
        margin: 2px;
    }
    input:focus {
        color: white;
        background-color: black;
    }
    #charcontainer {
        border: 0;
    }
    #charcontainer tr {
        outline: 2px solid black;
    }
    #charcontainer tr td {
        border: 0;
    }
    #tvcontainer {
        display: block;
        min-height: 40px;
        width: max-content;
        min-width: 200px;
        border: 1px solid black;
    }
    #edittable{
        margin: 10px auto; 
    }
    #edittable td {
        padding: 2px;
        vertical-align: top;
    }
    #cttable {
        border: 2px solid black;
    }
    #cttable tr, #cttable tr td{
        margin: 1px;
        padding: 1px;
    }
    #cttable tr td:hover, #savedobjs tr td:hover{
        color: white;
        background-color: black !important;
        cursor: pointer;
    }
    #savedobjs tr td {
        background-color: white;
    }
    #triggerrow .gametile{
        text-shadow: 1px 1px white, -1px 1px white, 1px -1px white, -1px -1px white;
    }
    .selected {
        outline: 2px solid rgb(0 255 255 / 0.35);
    }
    #savedobjpreview {
        outline: 2px solid black;
        position: absolute;
        display: none;
        background-color: white;
        z-index: 100;
        transform: translate(8px, -16px);
    }
    .mini {
        font-size: 11px;
        font-weight: 800;
    }
    #triggerrow span.active {
        outline: 4px solid cyan;
    }
    #playertile{
        position: absolute;
    }
</style>
</head>
<body>
    <div class="mid">-=- Text Dash -=-</div>
    <div class="mid">Click to jump.</div><br>

    <div class="mid" id="header">
        <span class="clickable" onclick="switchTab('main')">Main levels</span> | 
        <span class="clickable" onclick="switchTab('custom')">Custom levels</span> | 
        <span class="clickable" onclick="switchTab('edit')">Editor</span> | 
        <span class="clickable" onclick="switchTab('settings')">Settings</span>
    </div><br>

    <div class="mid" id="main">
        <div id="mainheader"><table class="kys"><tr class="kys">
            <td class="kys">Level number: </td>
            <td class="kys"><span id="mainlvid"></span></td>
            <td class="kys">&nbsp;|&nbsp;Best: <span id="mainbest">0</span>%</td>
            <td class="kys">&nbsp;|&nbsp;<span class="clickable" onclick="savefile.bests[levelID] = 0; savefile.attempts[levelID] = 0">Reset stats</span></td>
        </tr></table></div>
    </div>

    <div class="mid" id="gpstats">
        <div>Attempt <span id="attemptcount">0</span></div>
        <div><span id="percentage">0%</span></div>
        <div id="customheader"><span class="clickable" onclick="playLevel(true, selections.slotnumber)">Play</span> | <span class="clickable" onclick="window.cancelAnimationFrame(currentRenderer); clearInterval(levelLoopId);">Stop</span></div>
    </div>
    <div class="mid" id="custom">
        
    </div>
    <div id="slotselect"><table class="kys"><tr class="kys">
        <td class="kys">Slot number: </td>
        <td class="kys"><span id="slotnumber"></span></td>
        <td class="kys">&nbsp;|&nbsp;Best: <span id="custombest">0</span>%</td>
        <td class="kys">&nbsp;|&nbsp;<span class="clickable" onclick="savefile.customBests[levelID] = 0; savefile.customAttempts[levelID] = 0">Reset stats</span></td>
    </tr></table></div>

    <div class="mid" id="edit">
        <div>
            <span onmousedown="editorStates.velocity = -4000;" onmouseup="editorStates.velocity = 0;">&lt;&lt;</span>&nbsp;
            <span onmousedown="editorStates.velocity = -400;" onmouseup="editorStates.velocity = 0;">&lt;</span>&nbsp;
            <span id="editorpos">0</span>/<span id="editormax">100</span>&nbsp;
            <span onmousedown="editorStates.velocity = 400;" onmouseup="editorStates.velocity = 0;">&gt;</span>&nbsp;
            <span onmousedown="editorStates.velocity = 4000;" onmouseup="editorStates.velocity = 0;">&gt;&gt;</span>
        </div>
    </div>

    <div class="mid" id="settings">
        <div id="settingsheader"><a href="editorguide.html">See the editor guide</a></div>
        <table><tr>
            <td>
                <div>- Gameplay -</div>
                <div>Auto-retry <input name="setautoretry" id="setautoretry" type="checkbox" onchange="savefile.settings.autoRetry = setautoretry.checked;" checked></div>
                <div>Show attempts <input name="setshowatts" id="setshowatts" type="checkbox" onchange="savefile.settings.showAttempts = setshowatts.checked;" checked></div>
                <div>Show percentage <input name="setshowperc" id="setshowperc" type="checkbox" onchange="savefile.settings.showPrecentage = setshowperc.checked;" checked></div>
            </td>
            <td>
                <div>- Editor -</div>
                Coming soon (or never lmao)
            </td>
            <td>
                <div>- Global -</div>
                <div>Display size: <input name="setdispsize" id="setdispsize" type="number" placeholder="12" onchange="savefile.settings.gameSize = Number(setdispsize.value); document.getElementById('container').style.fontSize = savefile.settings.gameSize+'px'"></div>
            </td>
            <td>
                <div>- Savefile -</div>
                <span class="clickable" onclick="exportRaw(savefile);">Export savefile</span><br>
                <span class="clickable" onclick="importRaw(prompt('Enter savefile'), ()=>{loadSavefile(tempData)})">Import savefile</span><br>
                <span class="clickable" onclick="localStorage.removeItem('newtestdashsave')">Wipe savefile</span><br>
            </td>
        </tr></table>
    </div>

    <div id="container" class="mid">
        <div id="game" class="disable-select"></div>
    </div>

    <div id="practice" class="mid">
        <span id="practiceenter" class="clickable" onclick="inPractice=true; document.getElementById('practiceactive').style.display='block';  document.getElementById('practiceenter').style.display='none';">Enter practice mode</span>
        <span id="practiceactive" style="display: none;">
            <span class="clickable" onclick="inPractice=false; document.getElementById('practiceactive').style.display='none';  document.getElementById('practiceenter').style.display='block';">Exit practice mode</span><br>
            <span class="clickable" onclick="practicePoints.push([structuredClone(player1), structuredClone(player2), structuredClone(commonStates)]);">Place checkpoint (a)</span> | <span class="clickable" onclick="practicePoints.pop();">Remove checkpoint (s)</span>
        </span>
    </div>
    <div id="editorunder">
        <div class="mid">- Triggers -</div>
        <div id="triggerrow" class="mid disable-select"></div>
        <div id="triggeroptions" class="mid">
            <table class="kys"><tr class="kys"><td class="kys">Target:</td>
                <td class="kys"><span id="target1"></span></td>
                <td class="kys">&nbsp;| Property:</td>
                <td class="kys"><span id="target2"></span> </td></tr></table>
            <div id="tvcontainer" class="mid"><span id="tvalue" style="display: none; margin: 5px;">
                <table class="kys"><tr class="kys"><td class="kys">Value: </td><td class="kys">
                    <span id="tvalue-color" style="display: none;">
                        <input type="color" name="tvcolor" id="tvcolor"/> Alpha <input type="number" name="tvcolora" id="tvcolora" min="0" max="1" step="0.01" size="6"/>
                    </span>
                    <span id="tvalue-number" style="display: none;">
                        <input type="number" name="tvnumber" id="tvnumber" step="1" size="7"/>
                    </span>
                    <span id="tvalue-numbera" style="display: none;">
                        <input type="number" name="tvnumbera" id="tvnumbera" min="0" max="360" step="1" size="6"/>
                    </span>
                    <span id="tvalue-numberp" style="display: none;">
                        <input type="number" name="tvnumberp" id="tvnumberp" min="0" max="24" step="1" size="6"/>
                    </span>
                    <span id="tvalue-number1" style="display: none;">
                        <input type="number" name="tvnumber1" id="tvnumber1" min="0" max="1" step="0.01" size="6"/>
                    </span>
                    <span id="tvalue-blend" style="display: none;">
                        <span id="tvblendx"></span>
                    </span>
                </td>
                <td class="kys">
                    &nbsp;| Duration: <input type="number" name="tlength" id="tlength" step="1" min="1" size="10"/> |&nbsp;
                </td>
                <td class="kys">
                    Offset: <input type="number" name="toffset" id="toffset" step="1" min="1" size="10"/> |&nbsp;
                </td>
                <td class="kys">
                    <span onclick="addTrigger(); document.getElementById(`t${editorStates.triggerPosition}`).classList.remove('active');" class="clickable">Submit</span> |&nbsp;
                </td>
                <td class="kys"><span id="triggerdelete">
                    <span onclick="level.triggers[editorStates.tempTrigger.target1][editorStates.tempTrigger.target2][editorStates.x + editorStates.triggerPosition] = null;
                                    document.getElementById(`t${editorStates.triggerPosition}`).classList.remove('active');
                                    document.getElementById('tvalue').style.display = 'none';
                                    document.getElementById(`tvalue-${typeMap[selections.ttarget2]}`).style.display = 'none';
                    " class="clickable">Delete</span> |&nbsp;</span>
                </td>
                <td class="kys"><span id="triggercopy">
                    <span onclick="editorStates.clipboardTrigger = [level.triggers[editorStates.tempTrigger.target1][editorStates.tempTrigger.target2][editorStates.x + editorStates.triggerPosition], editorStates.tempTrigger.target1, editorStates.tempTrigger.target2]
                    " class="clickable">Copy</span> |&nbsp;</span>
                </td>
                <td class="kys"><span id="triggerpaste">
                    <span onclick="level.triggers[editorStates.tempTrigger.target1][editorStates.tempTrigger.target2][editorStates.x + editorStates.triggerPosition] = structuredClone(editorStates.clipboardTrigger[0]);
                    " class="clickable">Paste</span> |&nbsp;</span>
                </td>
                <td class="kys">
                    <span onclick="document.getElementById('tvalue').style.display = 'none';
                                    document.getElementById(`tvalue-${typeMap[selections.ttarget2]}`).style.display = 'none';
                                    document.getElementById(`t${editorStates.triggerPosition}`).classList.remove('active');
                    " id="triggercancel" class="clickable">Cancel</span> |&nbsp;
                </td>
                </tr></table>
            </span></div>
        </div>
        <table id="edittable">
            <tr>
                <td id="editsaving">
                    <div class="mid">- Saving -</div>
                    <div>[<span id="filename">No file</span>]</div>
                    <label for="infile" class="clickable">Choose file</label>
                    <div class="clickable" onclick="exportLevel(level, 'map'+levelID);">Export file</div>
                    <input type="file" name="infile" id="infile" accept=".tdl" style="display: none;" onchange="
                    document.getElementById('filename').textContent = infile.files.length == 0 ? 'No file' : infile.files[0].name;
                    "/>
                    <div class="clickable" onclick="importLevel(infile.files[0], ()=>{level=tempData});">Import file</div>
                    <div class="clickable" onclick="exportRaw(level)">Export JSON</div>
                    <div class="clickable" onclick="importRaw(window.prompt('Paste level string'), ()=>{level=tempData});">Import JSON</div>
                    <div class="clickable" onclick="for(let i=0; i<level.tiles.length; i++){level.tiles[i] = Array(25)} changeEditorLength(25); level.triggers = structuredClone(emptyTriggerObject);">Wipe level</div>
                </td>
                <td id="edittools">
                    <div class="mid">- Tools -</div>
                    <div id="selectbtn" class="clickable" onclick="editorStates.mode = 'select';">Select</div>
                    <div id="selectoptions" style="display: none;">
                        <div class="clickable" onclick="editorStates.whatToAdd = editorStates.selectedTiles; syncTileRows();">Use as object</div>
                        <div class="clickable" onclick="fillSelecion()">Fill with object</div>
                        <div class="clickable" onclick="editorStates.hasSelection = false; document.getElementById('selectbtn').style.display = 'inline-block'; document.getElementById('selectoptions').style.display = 'none';">Deselect</div>
                        <div id="savesel" class="clickable" onclick="savingCustom=true; savingFromSelection=true; document.getElementById('savesel').textContent='Click on a slot so save'">Save selection</div>
                    </div>
                    <table id="savedobjs"></table>
                    <div id="saveobj" class="clickable" onclick="savingCustom=true; savingFromSelection=false; document.getElementById('saveobj').textContent='Click on a slot so save'">Save current object</div>
                    <div><span class="clickable" id="startpospart1" onclick="handleStartposSetter()">Set start position</span></div>
                    <div><input type="checkbox" name="previewcolors" id="previewcolors" checked="true"/> Preview colors</div>
                    <div><input type="checkbox" name="previewmode" id="previewmode" checked="true"/> Property view: <span id="propviewtext">color</span></div>
                </td>
                <td id="chardialog">
                    <div class="mid">- Tile editor -</div>
                    <div id="singletile">
                        <div class="mid"><span class="clickable" onclick="goToTileRowPage(tileRowPage-1);">&lt;&lt;</span>&nbsp;&nbsp;&nbsp;<span class="clickable" onclick="goToTileRowPage(tileRowPage+1);">&gt;&gt;</span></div>
                        <div class="mini mid">Character/Color/State length/Behavior</div>
                        <table id="charcontainer"></table>
                        <div class="mid">
                            <span class="clickable" onclick="addNewTileRow()">Add&nbsp;state</span> | 
                            <span class="clickable" onclick="removeTileRow()">Remove&nbsp;state</span>
                        </div>
                        <div class="mid">Start of oscillation:<input type="number" name="tiletimebase" id="tiletimebase" min="0" step="1" size="9" onchange="editorStates.tempTile.timeBase=Number(tiletimebase.value)"/></div>
                        <div class="mid clickable" onclick="editorStates.whatToAdd=[[editorStates.tempTile]]">Use tile</div>
                    </div>
                    <div id="multitile" class="mid" style="display: none;">
                        <div>Multiple tiles being<br>used as object.</div>
                        <br>
                        <div class="clickable" onclick="editorStates.whatToAdd=[[editorStates.whatToAdd[0][0]]]; syncTileRows()">Return to single mode</div>
                        <br>
                    </div>
                    <br>
                    <div><input type="checkbox" name="deletemode" id="deletemode"/> Delete mode</div>
                </td>
                <td id="chartable">
                    <div class="mid">- Character table -<br>
                    Click on a character to copy it.<br>
                    Characters with special gameplay effects are colored.</div>
                    <div class="mid">
                        <span class="clickable" onclick="chartablePage-=1; buildChartable(chartablePage)" style="cursor: pointer;">&lt;&lt;</span> 
                        <span class="clickable" onclick="chartablePage = Math.floor(parseInt(prompt('Go to code point (hexadecimal)'), 16)/128); buildChartable(chartablePage)" id="ctrange"></span> 
                        <span class="clickable" onclick="chartablePage+=1; buildChartable(chartablePage)" style="cursor: pointer;">&gt;&gt;</span>
                    </div>
                </td>
            </tr>
        </table>
        <div id="savedobjpreview"></div>
    </div>
    <input type="text" id="tvblend" name="tvblend" style="display: none;"/><!--don't worry about this-->
<script>
var startupFlag = true;
var mainLevels = [];
var gameWidth = 25;
var gameHeight = 10;
var levelHeight = 10;
var tileString = ""; //new idea: ditch y subunit and use time based rise/fall like old times
///////////////////////////////
//       player stuff        //
///////////////////////////////

var player1 = {
    y: 3, //y increases downward, n|1200 = n+1|0
    mode: 0, gravity: 1,
    bufferCheck: true, previousTile: false,
    dashing: false, fallTimer: 4, var1: 0,
    jumpTimer: 0, jumpFrames: 0, hoverFrames: 0,
};
var player2 = {
    y: 3, //x and y values have subunits of 1/1200, the actual position is always rounded down
    mode: 0, gravity: -1,
    bufferCheck: true, previousTile: false,
    dashing: false, fallTimer: 4, var1: 0,
    jumpTimer: 0, jumpFrames: 0, hoverFrames: 0,
};
var commonStates = {
    height: 10, width: 100,
    x: 0, speed: 1, xSub: 0, frame: 0,
    P2Active: false,
};
var customLevel = false; 
var levelID = 0;
var practicePoints = []; //practice checkpoints are stored as [p1, p2, common states]
var speedValues = [100, 125, 160, 200, 240];
var playerIcons = ["X", "O", ">", "M", "U", "Đ"] //cube, ball, wave, spider, ufo, line fly
var gravityValues = [8, 9, 0, 8, 7, 0];
var jumpValues = [10, 0, 0, 0, 8, 0];

var renderOffset = 0; //at the beginning and the end of a level, the player needs to slide in/out without the camera moving, this variable is used to control that 

/*  -- TILE DEFINITION --
    chars: string[n]            display characters in order of appearance
    times: int[n]               time each character is visible in ms
    timeBase: int               starting x position for oscillation
    behavior: string[n]         how each character intercats with the player (solid, semisolid, kill, none, default)
    colorGroup: int(1~9)[n]     number of the color to use for each character
    *for special objects to have their intended effect, behavior must be set to default
    
    -- TRIGGER OBJECT DEFINITION --
    target1: c1, c2, ... c9, bg, fg, common
    target2: whatever that object may contain
    offset: delay before the transition (*10ms)
    time: duration of transition in frames (*10ms)
    trigger object:
    {(target1 as keys)]: {(target2 as keys): [(sparse array indexed by xpos) ...,[value, offset, time],...]}}
    classes are useless!!!!!!!!!!
*/
var testTile = {
    chars: [],
    times: [],
    timeBase: 0,
    behavior: [],
    colorGroup: []
};
var emptyTriggerObject = {
    c1: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c2: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c3: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c4: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c5: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c6: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c7: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c8: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    c9: {rgbaMain: [], rgbaGlow: [], glowRadius: [], glowOffsetX: [], glowOffsetY: [], blend: []},
    bg: {c1: [], c2: [], gradAngle: [], grad1: [], grad2: []},
    fg: {c1: [], c2: [], gradAngle: [], grad1: [], grad2: [], blend: []},
    common: {playerColumn: []}
}; //this may look bad,
var defaultValues = {
    c1: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c2: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c3: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c4: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c5: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c6: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c7: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c8: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    c9: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    bg: {c1: [255, 255, 255, 1], c2: [255, 255, 255, 1], gradAngle: 0, grad1: 0, grad2: 100},
    fg: {c1: [255, 255, 255, 0], c2: [255, 255, 255, 0], gradAngle: 0, grad1: 0, grad2: 100, blend: "normal"},
    common: {playerColumn: 5}
};
var lastTriggerFrame = {
    c1: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    c2: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    c3: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    c4: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    c5: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    c6: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    c7: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    c8: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    c9: {rgbaMain: 0, rgbaGlow: 0, glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: 0},
    bg: {c1: 0, c2: 0, gradAngle: 0, grad1: 0, grad2: 0},
    fg: {c1: 0, c2: 0, gradAngle: 0, grad1: 0, grad2: 0, blend: 0},
    common: {playerColumn: 0}
}; //gosh this is SO inefficient maybe you should have the triggers saved as a key array somewere and generate these with given data whatever dude IDC
var currentValues = structuredClone(defaultValues);
var typeMap = {
    rgbaMain: "color", //rgba array
    rgbaGlow: "color",
    c1: "color",
    c2: "color",
    glowRadius: "number",
    glowOffsetX: "number",
    glowOffsetY: "number",
    playerColumn: "numberp", //integer
    gradAngle: "numbera", //angle (0~360)
    grad1: "number1", //0~1
    grad2: "number1",
    blend: "blend" //blend mode (string)
}
function arrayToRGB(a){
    return `rgb(${a[0]} ${a[1]} ${a[2]} / ${a[3]})`
}
function cton(c, a){ //color formatters 
	var d = [0, 0, 0];
	for (i = 0; i < 3; i++){
		d[i] = Number("0x" + c.substring(2*i+1,2*i+3));
	}
    if (typeof a === "number") {
        d.push(a); //we add alpha if it exists
    }
	return d;
}
function ntoc(n){ //destroys alpha cannel (it's only used for setting color selectors anyway)
    if (n.length = 4) {n.pop;}
	var o = "#";
	for (i = 0; i < 3; i++){
		o += n[i].toString(16).padStart(2, "0");
	}
	return o;
}
var level = { //this will always hold the level being played/edited, we load them into this from a JSON file (?)
    version: "3.0.0",
    tiles: Array(levelHeight),
    triggers: structuredClone(emptyTriggerObject),
    initialState: [],
    speedChanges: [], //we want to keep track of this seperately to make trigger calculations easier [position, speed] (has to be sorted)
    //there must only be one speed chnage per column (unique x), if you try to add more than 1 then only the firts one applies
    //doing this also means that we have to disallow speed changes in mulistate tiles and also assume that every speed change is necessary
    startPosData: false,
};
for (let i = 0; i < levelHeight; i++) {
    level.tiles[i] = new Array(gameWidth); //grr why does this have to be done
}
function clamp(a, min, max){ //goes throuh arrays recusively (???????)
    if (Array.isArray(a)){
        for (let i = 0; i < a.length; i++){
            a[i] = clamp(a[i], min, max);
        }
        return a
    }
    return Math.min(Math.max(a, min), max);
}
function exists(tile){
    if (!tile){return false}
    if (!(Object.keys(tile).includes("timeBase") && Object.keys(tile).includes("colorGroup") && Object.keys(tile).includes("behavior") && Object.keys(tile).includes("times") && Object.keys(tile).includes("chars"))){return false;} //my god...
    return tile.colorGroup.length != 0 && tile.chars.length != 0 && tile.times.length != 0 && tile.behavior.length != 0;
}
///////////////////////////////
//        rendering          //
///////////////////////////////
function computeTriggerValue(target1, target2, x, subx, frame){
    frame = frame || posToFrame(x, subx);
    var currentTriggers = level.triggers[target1][target2];
    var nextIndex = currentTriggers.findLastIndex((e,i) => Array.isArray(e) && (i <= x));
    var nextTrigger = nextIndex == -1 ? [defaultValues[target1][target2],1,0] : currentTriggers[nextIndex]; //value, duration, offset
    var currentIndex = currentTriggers.findLastIndex((e,i) => Array.isArray(e) && (i < nextIndex)); //this will be -1 if the trigger doesn't exist, in that case we use default values
    var currentTrigger = currentIndex == -1 ? [defaultValues[target1][target2],1,0] : currentTriggers[currentIndex];
    var currentTriggerFrame = currentTab == "edit" ? posToFrame(nextIndex, 0) : lastTriggerFrame[target1][target2];
    var interpolationValue = clamp((frame - currentTriggerFrame - nextTrigger[2])/nextTrigger[1], 0, 1);

    if(target1 == "bg" && target2 == "c2"){
        console.log(frame, currentTriggerFrame);
    }

    if (typeMap[target2] == "blend") {return nextTrigger[0];}
    if (typeMap[target2] == "color") {return Array(4).fill(1).map((a, b) => interpolationValue*nextTrigger[0][b] + (1-interpolationValue)*currentTrigger[0][b])}
    //it's a regular number otherwise
    return interpolationValue*nextTrigger[0] + (1-interpolationValue)*currentTrigger[0];
}
function stateAt(tile, frame){
    if (!tile || !tile.times) {return false}
    if (tile.times.length == 1) {return {char: tile.chars[0], behavior: tile.behavior[0], colorGroup: tile.colorGroup[0]}}
    frame -= posToFrame(tile.timeBase, 0);
    frame = (9999999 + frame) % tile.times.reduce((a, b) => a + b); //shitty fix for the shitty modulo of js
    var index = 0;
    var soFar = 0;
    while (soFar < frame){
        soFar += tile.times[index];
        index++;
    }
    if (index == 0) {index = tile.times.length-1} //
    return {char: tile.chars[index-1], behavior: tile.behavior[index-1], colorGroup: tile.colorGroup[index-1]};
}
function tilePropertyRelative(dx, dy, pl, pr){
    if (pl.y + dy*pl.gravity < 0 || pl.y + dy*pl.gravity >= level.tiles.length || commonStates.x + dx < 0 || commonStates.x + dx >= level.tiles[0].length){
        return false;
    }
    //returns the behavior of a tile by a position relative to the player (y coord. adjsted with gravity, down is positive)
    //use only for gameplay purposes
    var k = stateAt(level.tiles[pl.y + dy*pl.gravity][commonStates.x + dx], commonStates.frame);
    if (k.behavior == "default"){
        k.behavior = "none";
        if (solidTiles.includes(k.char)){k.behavior = "solid"}
        if (semisolidTiles.includes(k.char)){k.behavior = "semisolid"}
        if (deadlyTiles.includes(k.char)){k.behavior = "kill"}
        if (specialTiles.includes(k.char)){k.behavior = "default"}
    }
    return k && k[pr];
}
var currentRenderer = -42; //requestfanimationframe id, use this to cancel the animation frame
function render(){
    //this bit is only run when you're in the editor -- it is enough to update editor stuff on render
    if (currentTab == "edit"){
        editorStates.editorSubpixel += editorStates.velocity;
        var distance = Math.floor(editorStates.editorSubpixel/1200);
        editorStates.x = Math.max(0, editorStates.x + distance);
        editorStates.editorSubpixel -= 1200*distance;
        document.getElementById("editorpos").textContent = editorStates.x;
        document.getElementById("editormax").textContent = level.tiles[0].length;
    } 
    renderOffset = Math.max(commonStates.x - Math.floor(currentValues.common.playerColumn), 0); //update this to allow continuous offsets
    renderOffset = Math.min(renderOffset, level.tiles[0].length - gameWidth);
    if (currentTab == "edit"){
        renderOffset = editorStates.x;
    }
    var renderFrame = currentTab == "edit" ? posToFrame(editorStates.x, editorStates.editorSubpixel) : commonStates.frame;
    //apply trigger effects (base off of frame number)
    for (var a of Object.keys(emptyTriggerObject)){
        for (var b of Object.keys(emptyTriggerObject[a])){
            currentValues[a][b] = computeTriggerValue(a, b, renderOffset + Math.floor(currentValues.common.playerColumn), currentTab == "edit" ? 0 : commonStates.xSub, renderFrame);
        }
    }
    //render tiles
    for (let i = 0; i < gameHeight; i++){
        for (let j = 0; j < gameWidth; j++){
            if (exists(level.tiles[i][j+renderOffset])){
                var currentTile = stateAt(level.tiles[i][j+renderOffset], renderFrame);
                var currentElement = document.getElementById(`${i}x${j}`);
                var currentColor = currentValues[`c${currentTile.colorGroup}`];
                currentElement.textContent = currentTile.char;
                currentElement.style.color = arrayToRGB(currentColor.rgbaMain);
                currentElement.style.textShadow = `${currentColor.glowOffsetX}px ${currentColor.glowOffsetY}px ${currentColor.glowRadius}px ${arrayToRGB(currentColor.rgbaGlow)}`;
                currentElement.style.mixBlendMode = currentColor.blend;
                if (currentTab == "edit" && !previewcolors.checked){
                    currentElement.style.color = previewmode.checked ? noprevColors[currentTile.colorGroup] : typeprevColors[currentTile.behavior];
                }
            }
            else {
                document.getElementById(`${i}x${j}`).textContent = "\xa0"; //regular spaces may disappear so we use a non-breaking one instead to be sure
            }
            document.getElementById(`e${i}x${j}`).classList.remove("selected");
        }
    }
    //render player, gameplay stats
    if (currentTab != "edit"){
        document.getElementById(`${player1.y}x${commonStates.x - renderOffset}`).textContent = playerIcons[player1.mode];
        document.getElementById(`${player1.y}x${commonStates.x - renderOffset}`).style.color = "black";
        if (commonStates.P2Active) {
            document.getElementById(`${player2.y}x${commonStates.x - renderOffset}`).textContent = playerIcons[player2.mode];
            document.getElementById(`${player2.y}x${commonStates.x - renderOffset}`).style.color = "blue";
        }
        document.getElementById("attemptcount").textContent = customLevel ? savefile.customAttempts[levelID] : savefile.attempts[levelID];
        document.getElementById("percentage").textContent = Math.floor(100*(commonStates.x + commonStates.xSub/1200)/level.tiles[0].length) + "%";
        if (currentTab == "main"){
            document.getElementById("mainbest").textContent = savefile.bests[levelID];
        } else {
            document.getElementById("custombest").textContent = savefile.customBests[levelID];
        }
    }
    if (inPractice){ //render practice points
        for (p of practicePoints){
            if(p[2].x - renderOffset > 0 && p[2].x - renderOffset < gameWidth){
                document.getElementById(`${p[0].y}x${p[2].x - renderOffset}`).textContent = "◊";
            }
        }
    }
    if (currentTab == "edit"){
        for (let i = 0; i < gameWidth; i++){
            //triggers
            var triggerElement = document.getElementById(`t${i}`);
            var thisTriggerValue = computeTriggerValue(editorStates.tempTrigger.target1, editorStates.tempTrigger.target2, renderOffset+i, 0, false);
            document.getElementById(`t${i}`).textContent = !!level.triggers[editorStates.tempTrigger.target1][editorStates.tempTrigger.target2][i+renderOffset] ? "O" : "\xa0";
            switch (typeMap[editorStates.tempTrigger.target2]){
                case "color":
                    triggerElement.style.backgroundImage = "none"; //if we added lines prevously we removed them 
                    triggerElement.style.backgroundColor = arrayToRGB(thisTriggerValue);
                    break;
                case "number":
                    drawLineGraphPart(triggerElement, thisTriggerValue/10 + 0.5);
                    break;
                case "numbera":
                    drawLineGraphPart(triggerElement, thisTriggerValue/360);
                    break;
                case "numberp":
                    drawLineGraphPart(triggerElement, thisTriggerValue/10);
                    break;
                case "number1":
                    drawLineGraphPart(triggerElement, thisTriggerValue);
                    break;
            }
            //selection
            if (editorStates.hasSelection){
                editorStates.selectedTiles = [];
                for (let i = editorStates.selection[0][0]; i <= editorStates.selection[1][0]; i++){
                    editorStates.selectedTiles.push([]);
                    for (let j = editorStates.selection[0][1]; j <= editorStates.selection[1][1]; j++){
                        if (i >= 0 && i < gameHeight && j-renderOffset >= 0 && j-renderOffset < gameWidth){
                            document.getElementById(`e${i}x${j-renderOffset}`).classList.add("selected");
                            editorStates.selectedTiles[i-editorStates.selection[0][0]].push(level.tiles[i][j]);
                        }
                    }
                }
            }
            if (editorStates.mode == "select" && !firstSelect){
                document.getElementById(`e${editorStates.selection[0][0]}x${editorStates.selection[0][1]-renderOffset}`).classList.add("selected"); //when you select the first
            }
            document.getElementById("propviewtext").textContent = previewmode.checked ? "color" : "behavior";
            //custom object preview
            if (shownPreview > 0 && savefile.savedObjects[shownPreview]){
                for (let i = 0; i < savefile.savedObjects[shownPreview].length; i++){
                    for (let j = 0; j < savefile.savedObjects[shownPreview][0].length; j++){
                        var w = stateAt(savefile.savedObjects[shownPreview][i][j], currentRenderer); //currentrenderer stores the timestamb generated by th eanimation frame of th erender function so it functions as a global timer, division is due to units 
                        if (w && w.behavior == "default"){
                            w.behavior = "none";
                            if (solidTiles.includes(w.char)){w.behavior = "solid"}
                            if (semisolidTiles.includes(w.char)){w.behavior = "semisolid"}
                            if (deadlyTiles.includes(w.char)){w.behavior = "kill"}
                            if (specialTiles.includes(w.char)){w.behavior = "default"}
                        }
                        try {
                            document.getElementById(`pre${i}x${j}`).style.color = previewmode.checked ? noprevColors[w.colorGroup] : typeprevColors[w.behavior];
                            document.getElementById(`pre${i}x${j}`).textContent = exists(savefile.savedObjects[shownPreview][i][j]) ? w.char : "\xa0";
                        }
                        catch(ee) {/* this is only here because this likes to crash randomly, may be an evalation order issue */}
                    }
                }
            }
            //start pos.
            if (level.startPosData && level.startPosData[2].x - renderOffset > 0 && level.startPosData[2].x - renderOffset < gameWidth){
            document.getElementById(`${level.startPosData[0].y}x${level.startPosData[2].x - renderOffset}`).textContent = "S";
            }
        }
        if (!inLevel){
            pressedKeys = [];
            releasedKeys  = [];
            mousePressed = false;
            mouseReleased = false;
        }
    }
    //render bg/fg
    var element = document.getElementById("gameBackground");
    var values = currentValues.bg;
    element.style.backgroundImage = `linear-gradient(${values.gradAngle}deg, ${arrayToRGB(values.c1)} ${values.grad1}%, ${arrayToRGB(values.c2)} ${values.grad2}%)`;
    if (currentTab == "edit" && !previewcolors.checked){
        element.style.backgroundImage = "linear-gradient(white)";
    }
    element = document.getElementById("gameForeground");
    values = currentValues.fg;
    element.style.backgroundImage = `linear-gradient(${values.gradAngle}deg, ${arrayToRGB(values.c1)} ${values.grad1}%, ${arrayToRGB(values.c2)} ${values.grad2}%)`;
    element.style.mixBlendMode = values.blend;
    if (currentTab == "edit" && !previewcolors.checked){
        element.style.backgroundImage = "linear-gradient(transparent)";
    }
    currentRenderer = window.requestAnimationFrame(render);
}
function drawLineGraphPart(target, ratio){
    target.style.backgroundImage = `linear-gradient(0deg, white ${ratio*100 - 4}%, black ${ratio*100}%, white ${ratio*100 + 4}%)`;
}

//gameplay

function physicsStep(pl){ //takes a player object (to allow for duals potentially)
    var currentTile = tilePropertyRelative(0, 0, pl, "behavior");
    var currentSpecialCharacter = null;
    if (tilePropertyRelative(0, 0, pl, "behavior") == "default"){
        currentSpecialCharacter = tilePropertyRelative(0, 0, pl, "char");
    }
    var neighboringTiles = []; 
    var neighboringSpecialCharacters = [];
    for (let i = -1; i < 2; i++){
        for (let j = -1; j < 2; j++){
            neighboringTiles.push(tilePropertyRelative(i, j, pl, "behavior"));
            if (tilePropertyRelative(i, j, pl, "behavior") == "default"){
                neighboringSpecialCharacters.push(tilePropertyRelative(i, j, pl, "char"));
            }
        }
    }
    var canHitHead = neighboringSpecialCharacters.includes("H") || pl.mode == 1 || pl.mode == 4; 
    var canWaveSlide = neighboringSpecialCharacters.includes("D");
    var tileBelow = tilePropertyRelative(0, 1, pl, "behavior");
    var tileAbove = tilePropertyRelative(0, -1, pl, "behavior");
    var tileFront = tilePropertyRelative(1, 0, pl, "behavior");
    var landedFlang = false;
    //collisions
    if ((tileBelow == "solid" || tileBelow == "semisolid") && pl.jumpFrames <= 0 &&
    (pl.mode != 2 || (pl.mode == 2 && canWaveSlide))){ //stand on the floor
        landedFlang = true;
        if (pl.jumpFrames == 0){
            pl.jumpTimer = 0;
        }
    }
    if (tileAbove == "solid" && canHitHead){ //hitting head
        pl.jumpFrames = 0;
        pl.hoverFrames = 0;
    }
    if (pl.y < 0 || pl.y >= levelHeight){ //falling out of the level
        die()
    }
    if (currentTile == "kill" || (currentTile == "solid" && (commonStates.xSub < 900 && commonStates.xSub > 300))){ //crashing into something
        die()
    }
    if (landedFlang){
        pl.fallTimer = 5;
    } else {
        pl.fallTimer--;
    }
    if (pl.falltimer > 0){
        landedFlang = true;
    }
    
    //special tile interaction
    if (neighboringSpecialCharacters.includes("0")){ //fix this
        commonStates.speed = 0;
    }
    if (neighboringSpecialCharacters.includes("1")){
        commonStates.speed = 1;
    }
    if (neighboringSpecialCharacters.includes("2")){
        commonStates.speed = 2;
    }
    if (neighboringSpecialCharacters.includes("3")){
        commonStates.speed = 3;
    }
    if (neighboringSpecialCharacters.includes("4")){
        commonStates.speed = 4;
    }
    if (neighboringSpecialCharacters.includes("5")){
        commonStates.speed = 5;
    }
    if (currentSpecialCharacter == "-"){
        pl.jumpFrames = 3;
        pl.hoverFrames = 2;
    }
    if (currentSpecialCharacter == "="){
        pl.gravity *= -1;
        pl.jumpFrames = 0;
        pl.hoverFrames = 0;
        pl.y += pl.gravity;
    }
    if (neighboringSpecialCharacters.includes(")")){
        pl.gravity = 1;
    }
    if (neighboringSpecialCharacters.includes("[")){
        pl.gravity = -1;
    }
    if (neighboringSpecialCharacters.includes("X")){
        pl.mode = 0;
    }
    if (neighboringSpecialCharacters.includes("O")){
        pl.mode = 1;
    }
    if (neighboringSpecialCharacters.includes(">")){
        pl.mode = 2;
    }
    if (neighboringSpecialCharacters.includes("M")){
        pl.mode = 3;
    }
    if (neighboringSpecialCharacters.includes("U")){
        pl.mode = 4;
    }
    if (neighboringSpecialCharacters.includes("Đ")){
        pl.mode = 5;
    }
    if (neighboringSpecialCharacters.includes("ß")){
        commonStates.P2Active = true;
        player2.y = player1.y
        player2.bufferCheck = true;
        player2.dashing = player1.dashing;
        player2.fallTimer = 0;
        player2.gravity = -player1.gravity;
        player2.hoverFrames = 0;
        player2.jumpFrames = 0;
        player2.mode = player1.mode;
        player2.jumpTimer = 0;
    }
    if (neighboringSpecialCharacters.includes("&")){
        commonStates.P2Active = false;
    }
    //click/hold interaction
    if (mousePressed || (isMouseDown && pl.bufferCheck)){
        switch (pl.mode){ //cube, ball, wave, spider, ufo, ???
            case 0:
                if (landedFlang) {
                    pl.jumpTimer = 0;
                    pl.jumpFrames = 2;
                    pl.hoverFrames = 1;
                }
                break;
            case 1:
                if (landedFlang){
                    pl.gravity *= -1;
                }
                break;
            case 2:
                pl.jumpTimer = 0;
                pl.jumpFrames = 9999;
                pl.hoverFrames = 0;
                break;
            case 3:
                if (landedFlang){
                    pl.gravity *= -1;
                    let dy = 0;
                    while (tilePropertyRelative(0, dy, pl, "behavior") != "solid"){
                        dy++;
                        if (pl.y+dy*pl.gravity < 0 || pl.y+dy*pl.gravity > levelHeight){
                            die();
                        }
                    }
                    pl.y += dy*pl.gravity-pl.gravity; 
                }
                break;
            case 4:
                pl.jumpTimer = 0;
                pl.jumpFrames = 2;
                pl.hoverFrames = 0;
                break;
            case 5:
                pl.jumpTimer = 0;
                pl.jumpFrames = 0;
                pl.hoverFrames = 9999;
                pl.gravity *= -1;
                break;
        }
        //orb interaction
        if (neighboringSpecialCharacters.includes("Q") && pl.mode != 2 && pl.mode != 5){
            pl.jumpTimer = 0;
            pl.jumpFrames = 2;
            pl.hoverFrames = 1;
        }
        if (neighboringSpecialCharacters.includes("@")){
            pl.gravity *= -1;
            if (pl.mode != 2) {
                pl.jumpFrames = 0;
                pl.hoverFrames = 0;
            }
        }
        if (neighboringSpecialCharacters.includes("Ö")){
            pl.gravity *= -1;
            if (pl.mode != 2 && pl.mode != 5){
                pl.jumpTimer = 0;
                pl.jumpFrames = 2;
                pl.hoverFrames = 1;
            }
        }
        if (neighboringSpecialCharacters.includes("¤")){
            pl.gravity *= -1;
            let dy = 0;
            while (tilePropertyRelative(0, dy, pl, "behavior") != "solid"){
                dy++;
                if (pl.y+dy*pl.gravity < 0 || pl.y+dy*pl.gravity > levelHeight){
                    die();
                }
            }
            pl.y += dy*pl.gravity-pl.gravity; 
        }
        if (neighboringSpecialCharacters.includes("~")){
            pl.dashing = true;
            pl.jumpFrames = 0;
        }
        if (neighboringSpecialCharacters.includes("÷")){
            pl.dashing = true;
            pl.gravity *= -1;
            pl.jumpFrames = 0;
        }
        pl.bufferCheck = false;
    }
    //release interaction
    if (mouseReleased){
        switch (pl.mode){ //cube, ball, wave, spider, ufo, ???
            case 0:
                break;
            case 1:
                break;
            case 2:
                pl.jumpFrames = 0;
                pl.hoverFrames = 0;
                break;
            case 3:
                break;
            case 4:
                break;
            case 5:
                pl.jumpFrames = 0;
                pl.hoverFrames = 0;
                break;
        }
        pl.bufferCheck = true;
        pl.dashing = false;
    }
    //calculate the movemets
    let yDir = 1;
    if (pl.hoverFrames > 0 || landedFlang || pl.dashing){yDir = 0}
    if (pl.jumpFrames > 0){yDir = -1}
    if (pl.jumpTimer <= 0){
        pl.y += pl.gravity * yDir;
        pl.jumpTimer = gravityValues[pl.mode];
        if (pl.mode == 2 || pl.mode == 5){pl.jumpTimer = Math.floor(1200/speedValues[commonStates.speed])}
        if (pl.jumpFrames == 0){
            pl.hoverFrames--;
        }
        else {
            pl.jumpFrames--;
        }
    }
    pl.jumpTimer--;
    pl.previousTile = currentTile;
}
//attempt counter template (commonStates.customLevel ? savefile.customAttempts : savefile.attempts)[commonStates.levelID]
function gameLoop(){
    if (pressedKeys.includes("a")){
        practicePoints.push([structuredClone(player1), structuredClone(player2), structuredClone(commonStates)]);
    }
    if (pressedKeys.includes("s")){
        practicePoints.pop();
    }
    physicsStep(player1);
    if (commonStates.P2Active) {physicsStep(player2)}
    var lastX = structuredClone(commonStates.x);
    commonStates.xSub += speedValues[commonStates.speed];
    if (commonStates.xSub > 1200) {commonStates.xSub -= 1200; commonStates.x += 1}
    if (commonStates.xSub < 0) {commonStates.xSub += 1200; commonStates.x -= 1}
    commonStates.frame += 1;
    for (let i of Object.keys(lastTriggerFrame)){
        for (let j of Object.keys(lastTriggerFrame[i])){
            if (level.triggers[i][j][commonStates.x] && commonStates.x > lastX){
                lastTriggerFrame[i][j] = commonStates.frame;
            }
        }
    }
    if (commonStates.x >= level.tiles[0].length){ // level completion
        win();
    }
    pressedKeys = [];
    releasedKeys  = [];
    mousePressed = false;
    mouseReleased = false;
}
var replayerID = -42;
function die(){
    if (!inPractice && !level.startPosData){
        if (customLevel){
            savefile.customBests[levelID] = Math.max(savefile.customBests[levelID], Math.floor(100*(commonStates.x + commonStates.xSub/1200)/level.tiles[0].length));
        } else {
            savefile.bests[levelID] = Math.max(savefile.bests[levelID], Math.floor(100*(commonStates.x + commonStates.xSub/1200)/level.tiles[0].length));
        }
    }
    if(!currentTab == "edit"){window.cancelAnimationFrame(currentRenderer);}
    clearInterval(levelLoopId);
    for (let i = 0; i < gameHeight; i++){
        for (let j = 0; j < gameWidth; j++){
            document.getElementById(`${i}x${j}`).textContent = "\xa0";
        }
    }
    if (savefile.settings.autoRetry && inLevel){
        replayerID = setTimeout(playLevel, 200, customLevel, levelID);
    }
}
function win(){
    if (!inPractice && !level.startPosData){
        if (customLevel){
            savefile.customBests[levelID] = 100;
        } else {
            savefile.bests[levelID] = 100;
        }
    }
    document.getElementById("percentage").textContent = "Level complete!";
    window.cancelAnimationFrame(currentRenderer);
    clearInterval(levelLoopId);
}
///////////////////////////////
//          editor           //
///////////////////////////////

var editorStates = {
    x: 0,
    editorSubpixel: 0,
    velocity: 0,
    mode: "add", //add, select,...?
    colorDialogTarget: "undefined",
    tempColor: {rgbaMain: [0, 0, 0, 1], rgbaGlow: [0, 0, 0, 0], glowRadius: 0, glowOffsetX: 0, glowOffsetY: 0, blend: "normal"},
    tempTile: structuredClone(testTile),
    tempTrigger: {target1: "c1", target2: "rgbaMain", value: null, offset: 0, duration: 0},
    clipboardTrigger: null,
    triggerPosition: 0,
    numberDialogState: {value: 0, min: 0, max: 1, integer: false},
    whatToAdd: [[{}]], //2d tile array
    whatToOverwrite: {chars: [true], times: [true], timeBase: [true], behavior: [true], colorGroup: [true], stateNumber: [true]}, //add later
    hasSelection: false,
    selection: [[0, 0], [0, 0]], //top left x,y; bottom right x,y
    selectedTiles: [[{}]],
}
function posToFrame(x, subx){ //only used in editor previews ugh guys please appreciate this
    if (x < 0){return 0} //needed due to how triggers are calculated
    var result = 0;
    subx += x * 1200 //convert to pure subpixles
    var thisTriggerDistance = 42; //if the remaining subx is less than this we know that we finish before the next speed change
    if (level.speedChanges.length == 0) {
        return Math.floor(subx / speedValues[1]); //special case for a level with no speed changes
    } 
    else {
        thisTriggerDistance = (level.speedChanges[0][0]-1) * 1200;
        if (subx < thisTriggerDistance){
            return Math.floor(subx / speedValues[1]); //special case for first speed change (ends before it)
        }
        else {
            result = thisTriggerDistance / speedValues[1] // (doesn't end before)
            subx -= thisTriggerDistance;
        }
    }
    for (let i = 0; i < level.speedChanges.length-1; i++){
        thisTriggerDistance = level.speedChanges[i+1][0] - level.speedChanges[i][0];
        thisTriggerDistance *= 1200; //convert to subpixels
        var currentSpeed = speedValues[level.speedChanges[i][1]];
        if (subx < thisTriggerDistance){
            result += Math.floor(subx / currentSpeed);
            return result;
        }
        else {
            result += thisTriggerDistance / currentSpeed
            subx -= thisTriggerDistance;
        }
    }
    result += Math.floor(subx / speedValues[level.speedChanges[level.speedChanges.length-1][1]]);
    return result;
}
function removeNthElement(a, n){
    return a.slice(0, n).concat(a.slice(n+1, a.length)); //this is the main target for optimization
}
const enc = new TextEncoder();
const dec = new TextDecoder();
function exportLevel(from, filename){ //a questionable inclusion for sure
    var dataArray = Array(...enc.encode(JSON.stringify(from)));
    var EDataArray = [];
    var decoderArray = [];
    var EDecoderArray = []; //extra bits; we are using a 9-bit encoding so we seperate out the 9th bits and store them separaely
    var foundPairs = [];
    var nextValue = 256;
    var occurences = new Map();
    while (nextValue < 512){
        //find best pair
        var pairs = dataArray.map((a, b, c) => 512*c[b]+c[b+1]);
        pairs.pop();
        var foundPair = -1
        for (p of pairs) {
            occurences.set(p, occurences.get(p)+1 || 1);
            if (occurences.get(p) > 2){
                foundPair = p; //uses a greedy pair-finder, may replace with "find most frequent pair" if it has little effect on prefromance
                break;
            }
        }
        if (foundPair < 0){break;} // this means nothing was found
        //combine entries
        decoderArray.push(Math.floor(p/512), p%512);
        for (let i = pairs.length-1; i>=0; i--){
            if (pairs[i] == foundPair){
                dataArray = removeNthElement(dataArray, i);
                dataArray[i] = nextValue;
                i -= 1;
            }
        }
        nextValue++;
        occurences.clear();
    }
    EDataArray = dataArray.map(x => Math.floor(x/256));
    dataArray = dataArray.map(x => x % 256);
    EDecoderArray = decoderArray.map(x => Math.floor(x/256));
    decoderArray = decoderArray.map(x => x % 256);
    var edt2 = [];
    var ede2 = [];
    for (let i = 0; i < EDataArray.length; i+=8){ //process arrays....
        var edts = 0;
        for (let j = 0; j < 8; j++){
            if(i+j < EDataArray.length){edts += EDataArray[i+j]*(2**(7-j))}
        }
        edt2.push(edts);
    }
    for (let i = 0; i < EDecoderArray.length; i+=8){
        var edes = 0;
        for (let j = 0; j < 8; j++){
            if(i+j < EDecoderArray.length){edes += EDecoderArray[i+j]*(2**(7-j))}
        }
        ede2.push(edes);
    }
    EDataArray = edt2;
    EDecoderArray = ede2;

    var fullDataArray = [Math.floor(dataArray.length/2**24), Math.floor(dataArray.length%2**24 / 2**16), Math.floor(dataArray.length%2**16 / 2**8), Math.floor(dataArray.length%2**8),
    Math.floor(decoderArray.length/2**24), Math.floor(decoderArray.length%2**24 / 2**16), Math.floor(decoderArray.length%2**16 / 2**8), Math.floor(decoderArray.length%2**8),
    Math.floor(EDataArray.length/2**24), Math.floor(EDataArray.length%2**24 / 2**16), Math.floor(EDataArray.length%2**16 / 2**8), Math.floor(EDataArray.length%2**8)];
    fullDataArray = fullDataArray.concat(dataArray, decoderArray, EDataArray, EDecoderArray);
    //pack into 8bit array
    var exportArray = new Uint8Array(fullDataArray);
    var exportData = new Blob([exportArray]);
    //export
    var exportURL = URL.createObjectURL(exportData);
    var q = document.createElement("a");
    q.download = `${filename}.tdl`;
    q.href = exportURL;
    q.click();
    URL.revokeObjectURL(exportURL);
}
function importLevel(x, after){
    x.arrayBuffer().then((data) => {
        var w = new Uint8Array(data);
        var q = Array(...w);
        //find datas
        var dataOffset = 12;
        var decodeOffset = dataOffset + q[0]*2**24 + q[1]*2**16 + q[2]*2**8 + q[3];
        var EDataOffset = decodeOffset + q[4]*2**24 + q[5]*2**16 + q[6]*2**8 + q[7];
        var EDecodeOffset = EDataOffset+ q[8]*2**24 + q[9]*2**16 + q[10]*2**8 + q[11];
        
        var dataArray = q.slice(dataOffset, decodeOffset);
        var decoderArray = q.slice(decodeOffset, EDataOffset);
        var EDataArray = q.slice(EDataOffset, EDecodeOffset);
        var EDecoderArray = q.slice(EDecodeOffset);

        dataArray = dataArray.map((v, i) => v + (EDataArray[Math.floor(i/8)] & 2**(7-i%8) ? 256 : 0));
        decoderArray = decoderArray.map((v, i) => v + (EDecoderArray[Math.floor(i/8)] & 2**(7-i%8) ? 256 : 0)); //and now i understand why little-endian exists

        var nextValue = Math.max(...dataArray);
        for (let i=decoderArray.length-2; i>=0; i-=2){
            dataArray = dataArray.flatMap((d) => d == nextValue ? [decoderArray[i], decoderArray[i+1]] : d);
            nextValue--;
        }
        importRaw(dec.decode(new Uint8Array(dataArray)), after); //shockingly i don't feel terrible about this code
    });
}
function exportRaw(from){
    navigator.clipboard.writeText(JSON.stringify(from));
    window.alert("Copied to clipboard");
}
var tempData = {};
function importRaw(data, after){
    try {
        var tempLevel = JSON.parse(data);
        if (tempLevel){
            tempData = JSON.parse(data);
            after();
        }
        else {
            window.alert("Import error: no object found");
        }
    } catch (ee) {
        window.alert(`Import error: corrupted data`);
    }
}
function addTiles(y, x){
    changeEditorLength(Math.max(editorStates.whatToAdd.length + x, level.tiles[0].length));
    for (let i = 0; i < editorStates.whatToAdd[0].length; i++){
        for (let j = 0; j < editorStates.whatToAdd.length; j++){
            if (y+j >= 0 && x+i < level.tiles[0].length && exists(editorStates.whatToAdd[j][i])){ //temporary fix... replacement options to be added later, or never
                var thisTile = editorStates.whatToAdd[j][i];
                if (level.speedChanges.map(a => a[0]).indexOf(x+i) != -1 && level.speedChanges[level.speedChanges.map(a => a[0]).indexOf(x+i)][2] == y+j){ //remove (overwrite) speed changes
                    level.speedChanges = removeNthElement(level.speedChanges, level.speedChanges.map(a => a[0]).indexOf(x+i));
                }
                if (speedchangeTiles.includes(thisTile.chars[0]) && !level.speedChanges.map(a => a[0]).includes(x+i)){ //add speed changes
                    level.speedChanges.push([x+i, Number(thisTile.chars[0]), y+j]);
                    level.speedChanges.sort((a, b) => a[0] - b[0]); //must be sorted for thing to work properly
                }
                level.tiles[y+j][x+i] = structuredClone(thisTile);
            }
        }
    }
}
function changeEditorLength(newlen){
    if (newlen == level.tiles[0].length){return;}
    newlen = clamp(newlen, gameWidth, 4096); //arbitrary max level length
    if (level.tiles[0].length > newlen){
        //make smaller
        while (level.tiles[0].length > newlen){
            for (var tr of level.tiles){
                tr.pop();
            }
        }
    }
    else {
        //make larger
        while (level.tiles[0].length < newlen){
            for (var tr of level.tiles){
                tr.push(null);
            }
        }
    }
}
var firstSelect = true;
function selectTiles(x, y){
    if (firstSelect){
        editorStates.selection[0] = [x, y];
        firstSelect = false;
    }
    else {
        editorStates.selection[1] = [x, y];
        if (editorStates.selection[0][0] > editorStates.selection[1][0]){
            var c = editorStates.selection[0][0];
            editorStates.selection[0][0] = editorStates.selection[1][0];
            editorStates.selection[1][0] = c;
        }
        if (editorStates.selection[0][1] > editorStates.selection[1][1]){
            var cc = editorStates.selection[0][1];
            editorStates.selection[0][1] = editorStates.selection[1][1];
            editorStates.selection[1][1] = cc;
        } //fuck you
        editorStates.mode = "add";
        editorStates.hasSelection = true;
        firstSelect = true;
        editorStates.selectedTiles = [];
        for (let i = editorStates.selection[0][0]; i <= editorStates.selection[1][0]; i++){
            editorStates.selectedTiles.push([]);
            for (let j = editorStates.selection[0][0]; j <= editorStates.selection[1][0]; j++){
                editorStates.selectedTiles[i-editorStates.selection[0][0]].push(level.tiles[i][j]);
            }
        }
        document.getElementById("selectbtn").style.display = "none";
        document.getElementById("selectoptions").style.display = "inline-block";
    }
}
function fillSelecion(){
    var fillPattern = deletemode.checked ? [[null]] : editorStates.whatToAdd;
    for (let i = editorStates.selection[0][0]; i <= editorStates.selection[1][0]; i++){
            for (let j = editorStates.selection[0][1]; j <= editorStates.selection[1][1]; j++){
                level.tiles[i][j] = fillPattern[i % fillPattern.length][j % fillPattern[0].length]
            }
        }
}
var inLevel = false;
var inPractice = false;
var levelLoopId;
function playLevel(cust, num){
    for (let i of Object.keys(lastTriggerFrame)){
        for (let j of Object.keys(lastTriggerFrame[i])){
            lastTriggerFrame[i][j] = 0;
        }
    }
    window.cancelAnimationFrame(currentRenderer);
    clearInterval(levelLoopId);
    if(startupFlag){return;}
    var loadPP = levelID == num && customLevel == cust && inPractice && practicePoints.length > 0;
    if (!loadPP){
        practicePoints = [];
    }
    if (level.startPosData){
        loadPP = true;
        practicePoints[0] = level.startPosData;
    }
    player1 = loadPP ? structuredClone(practicePoints[practicePoints.length-1][0]) : {
    y: 3,
    mode: 0, gravity: 1,
    bufferCheck: true, previousTile: false,
    dashing: false, fallTimer: 4, var1: 0,
    jumpTimer: 0, jumpFrames: 0, hoverFrames: 0,};

    player2 = loadPP ? structuredClone(practicePoints[practicePoints.length-1][1]) : {
    y: 3,
    mode: 0, gravity: -1,
    bufferCheck: true, previousTile: false,
    dashing: false, fallTimer: 4, var1: 0,
    jumpTimer: 0, jumpFrames: 0, hoverFrames: 0,};

    commonStates = loadPP ? structuredClone(practicePoints[practicePoints.length-1][2]) : {
    x: 0, speed: 1, xSub: 0, frame: 0,
    P2Active: false,};

    levelID = num;
    customLevel = cust;
    level = cust ? structuredClone(savefile.maps[num]) : structuredClone(mainLevels[num]);
    inLevel = true;
    if (cust) {savefile.customAttempts[num]++;} else {savefile.attempts[num]++;}
    render();
    levelLoopId = setInterval(gameLoop, 10);
}
function exitLevel(){
    window.cancelAnimationFrame(currentRenderer);
    clearInterval(levelLoopId);
    inLevel = false;
}
var savefile = {
    settings: {
        autoRetry: true,
        gameSize: 12,
        autoCheckpoints: false,
        hotkeys: true,
        showAttempts: true,
        showPrecentage: true,
    },
    savedObjects: Array(16),
    bests: [],
    customBests: Array(32).fill(0),
    attempts: [],
    customAttempts: Array(32).fill(0),
    maps: Array(32).fill(level),
};
///////////////////////////////
//     html constructors     //
///////////////////////////////
function makeFiller(){ //creates an empty element the same size as the game screen
    var q = ""
    for (let i = 0; i < gameWidth; i++){q += "&nbsp;"}
    for (let i = 0; i < gameHeight; i++){q += "<br>"}
    return q;
}
tileString += "<span id=playertile></span>"
tileString += `<span id="gameBackground">${makeFiller()}</span><span id="gameForeground">${makeFiller()}</span>`;
tileString += "<span id='editorInterface'>";
for (let i = 0; i < gameHeight; i++){
    for (let j = 0; j < gameWidth; j++){
        tileString += `<span id="e${i}x${j}" class="editortile" onmouseenter="tileHoverHandler(${i},${j},false)" onmousedown="tileHoverHandler(${i},${j},true)">&nbsp;</span>`
    }
    tileString += "<br>" //TODO add a subcontainer to each tile which is absolutely positioned and draw to those to truly fix rendering forever
}
tileString += "</span>"
tileString += "<span id='gameInterface'>";
for (let i = 0; i < gameHeight; i++){
    for (let j = 0; j < gameWidth; j++){
        tileString += `<span id="c${i}x${j}" class="gametilecontainer"><span id="${i}x${j}" class="gametile">&nbsp;</span>&nbsp;</span>`
    }
    tileString += "<br>"
}
tileString += "</span>"
document.getElementById("game").innerHTML = tileString;

var currentTab = "blablabla"
var tabs = {
    main: ["main", "container", "practice", "gpstats"],
    custom: ["custom", "container", "practice", "slotselect", "gpstats"],
    edit: ["edit", "container", "editorunder", "editorInterface", "slotselect"],
    settings: ["settings"]
};
var everyTab = ["main", "container", "custom", "practice", "edit", "editorunder", "settings", "editorInterface", "slotselect", "gpstats"]; //questionable
function switchTab(tabname){
    die();
    practicePoints = [];
    window.cancelAnimationFrame(currentRenderer);
    clearInterval(levelLoopId);
    clearTimeout(replayerID);
    //what to do when switching FROM this tab
    switch (tabname){
        case "main":
            break;
        case "custom":
            savefile.maps[selections.slotnumber] = structuredClone(level);
            break;
        case "edit":
            window.cancelAnimationFrame(currentRenderer);
            break;
        case "settings":
            break;
    }
    document.getElementById("game").classList.remove(currentTab);
    document.getElementById("game").classList.add(tabname);
    for (t of everyTab){
        document.getElementById(t).style.display = tabs[tabname].includes(t) ? "block" : "none";
    }
    currentTab = tabname;
    //what to do when switching TO this tab
    switch (tabname){
        case "main":
            customLevel = false;
            break;
        case "custom":
            customLevel = true;
            level = structuredClone(savefile.maps[selections.slotnumber]);
            break;
        case "edit":
            render();
            break;
        case "settings":
            break;
    }
}
switchTab("main");
var selections = {}
function buildSelector(name, target, options, otherfn, condition){ //otherfn is called when an option is selected (supply as string)
    condition ||= "true";
    //selections[name] = options[0];
    document.getElementById(target).classList.add("selector");
    var result = `<span id="${name}-text">${options[0]}</span><span class="expander" onclick="if(${condition}){document.getElementById('${name}-options').style.display='flex'}">+</span>
                <span id="${name}-options" class="selectionoptions" style="display:none">`
        for (let i = 0; i < options.length; i++){
            result += `<span class="selectionoption ${window.navigator.userAgent.includes("Firefox")?"ff-fix":""}" onclick="document.getElementById('${name}-options').style.display='none';
                    document.getElementById('${name}-text').textContent='${options[i]}';
                    selections['${name}']='${options[i]}';${otherfn}">${options[i]}</span><br>`;
        }
    result += `</span>`;
    document.getElementById(target).innerHTML = result; //html has selection menus built in ... but im quirky like that
    document.getElementById(target).children[2].firstChild.click(); //initalize values
}
function destroySelector(name){
    selections["name"] = null;
}
var blendModes = ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
function syncSelectors(){
    for (const [key, value] of Object.entries(selections)){
        document.getElementById(`${key}-text`).textContent = value;
    }
}
var tileRowPage = 0;
var tileRowsPerPage = 3;
var activeTileRows = 0;
function addNewTileRow(){
    activeTileRows++;
    editorStates.tempTile.chars.push("");
    editorStates.tempTile.times.push(0);
    editorStates.tempTile.colorGroup.push(1);
    editorStates.tempTile.behavior.push("default");
    var characterContainer = document.getElementById("charcontainer");
    var addingIndex = characterContainer.childElementCount;
    var currentRow = characterContainer.appendChild(document.createElement("tr"));
    currentRow.id = `tilerow${addingIndex}`;
    currentRow.innerHTML = `<td class="tile-char"><input type="text" name="ttext${addingIndex}" id="ttext${addingIndex}" minlength="1" maxlength="2" size="1" onchange="editorStates.tempTile.chars[${addingIndex}] = String.fromCodePoint(ttext${addingIndex}.value.codePointAt(0))" /></td>
                            <td class="tile-color"><span id="colselect${addingIndex}"></span></td>
                            <td class="tile-length"><input type="number" name="tlength${addingIndex}" id="tlength${addingIndex}" size="10" onchange="editorStates.tempTile.times[${addingIndex}] = Number(tlength${addingIndex}.value)" /></td>
                            <td class="tile-behavior"><span id="behaviorselect${addingIndex}"></span></td>`;
    buildSelector(`tcolor${addingIndex}`, `colselect${addingIndex}`, [1,2,3,4,5,6,7,8,9], `editorStates.tempTile.colorGroup[${addingIndex}] = Number(selections.tcolor${addingIndex})`);
    buildSelector(`tbehavior${addingIndex}`, `behaviorselect${addingIndex}`, ["solid", "semisolid", "kill", "none", "default"], `editorStates.tempTile.behavior[${addingIndex}] = selections.tbehavior${addingIndex}`);
    goToTileRowPage(tileRowPage);
}
function removeTileRow(){
    if (!document.getElementById("charcontainer").hasChildNodes()){return true;} //check if there is already nothing there
    if (document.getElementById("charcontainer").childElementCount == tileRowPage * tileRowsPerPage + 1){tileRowPage--;}
    activeTileRows--;
    document.getElementById("charcontainer").lastElementChild.remove();
    editorStates.tempTile.chars.pop();
    editorStates.tempTile.times.pop();
    editorStates.tempTile.colorGroup.pop();
    editorStates.tempTile.behavior.pop();
    goToTileRowPage(tileRowPage);
}
function syncTileRows(){
    //used when loading a tile(s) into the tile editor
    if (editorStates.whatToAdd.length == 1 && editorStates.whatToAdd[0].length == 1){ //one tile being loaded, make rows
        document.getElementById("singletile").style.display = "inline-block";
        document.getElementById("multitile").style.display = "none";
        var selectedTile = editorStates.whatToAdd[0][0];
        //adjust row number
        while (activeTileRows < selectedTile.chars.length){
            addNewTileRow();
        }
        while (activeTileRows > selectedTile.chars.length){
            removeTileRow();
        }
        //load data
        for (let i = 0; i < activeTileRows; i++){
            document.getElementById(`ttext${i}`).value = selectedTile.chars[i];
            document.getElementById(`tlength${i}`).value = selectedTile.times[i];
            selections[`tcolor${i}`] = selectedTile.colorGroup[i];
            selections[`tbehavior${i}`] = selectedTile.behavior[i];
        }
        syncSelectors();
    }
    else { //multile tiles being loaded, use multiple selection dialog
        document.getElementById("singletile").style.display = "none";
        document.getElementById("multitile").style.display = "inline-block";
    }
}
function goToTileRowPage(page){
    if (page < 0) {return;}
    var totalRows = document.getElementById("charcontainer").childElementCount;
    if (totalRows <= page * tileRowsPerPage){return;}
    tileRowPage = page;
    for (let i = 0; i < totalRows; i++){
        document.getElementById(`tilerow${i}`).style.display = "none";
        if (i >= page * tileRowsPerPage && i < totalRows && i < (page+1) * tileRowsPerPage) {
            document.getElementById(`tilerow${i}`).style.display = "table-row";
        }
    }
}
//maybe make a custom color selector too?

//trigger row
tileString = "";
for (let i = 0; i < gameWidth; i++){
    tileString += `<span id="t${i}" class="gametile" onclick="openTriggerMenu(${i})">&nbsp;</span>`;
}
document.getElementById("triggerrow").innerHTML = tileString;
buildSelector("ttarget1", "target1", Object.keys(defaultValues), "buildSelector('ttarget2', 'target2', Object.keys(emptyTriggerObject[selections.ttarget1]), 'editorStates.tempTrigger.target2 = selections.ttarget2'); editorStates.tempTrigger.target1 = selections.ttarget1; editorStates.tempTrigger.target2 = Object.keys(emptyTriggerObject[selections.ttarget1])[0];");
buildSelector("tvblendx", "tvblendx", blendModes, "tvblend.value = selections.tvblendx"); //silly workaround
buildSelector("slotnumber", "slotnumber", Array(32).fill(0).map((x, i) => i), ` if (currentTab == 'edit'){
                                                                                    savefile.maps[levelID] = structuredClone(level);
                                                                                }
                                                                                levelID = selections.slotnumber;
                                                                                level = structuredClone(savefile.maps[levelID]);
                                                                                die();
                                                                                clearTimeout(replayerID);`, "true");
buildSelector("mainlvid", "mainlvid", Array(5).fill(0).map((x, i) => i+1), "playLevel(true, Number(selections.mainlvid))", "true");
function openTriggerMenu(pos){
    if (document.getElementById("tvalue").style.display == "block"){return;} //dont open multiple at once
    document.getElementById("tvalue").style.display = "block";
    document.getElementById(`tvalue-${typeMap[editorStates.tempTrigger.target2]}`).style.display = "inline";
    document.getElementById("triggerdelete").style.display = "none";
        document.getElementById("triggercopy").style.display = "none";
    var toLoad = level.triggers[editorStates.tempTrigger.target1][editorStates.tempTrigger.target2][editorStates.x + pos];
    if (toLoad){ //load trigger if it exists
        switch (typeMap[editorStates.tempTrigger.target2]){
            case "color":
                tvcolor.value = ntoc(toLoad[0]);
                tvcolora.value = toLoad[0][3];
                break;
            case "blend":
                selections.tvblendx = toLoad[0];
                break;
            default: //it's a number otherwise
                document.getElementById(`tv${typeMap[editorStates.tempTrigger.target2]}`).value = toLoad[0];
        }
        tlength.value = toLoad[1];
        toffset.value = toLoad[2];
        //options only needed for dealing with triggers that exist
        document.getElementById("triggerdelete").style.display = "inline";
        document.getElementById("triggercopy").style.display = "inline";
    }
    //only show paste when type matches
    document.getElementById("triggerpaste").style.display = (editorStates.clipboardTrigger && typeMap[editorStates.tempTrigger.target2] == typeMap[editorStates.clipboardTrigger[2]]) ? "inline" : "none";
    document.getElementById(`t${pos}`).classList.add("active");
    editorStates.triggerPosition = pos;
}
function addTrigger(){
    var triggerValue = document.getElementById(`tv${typeMap[selections.ttarget2]}`).value;
    switch (typeMap[selections.ttarget2]){
        case "color":
            triggerValue = cton(triggerValue, Number(tvcolora.value));
            break;
        case "number": case "numbera": case "numberp": case "number1":
            triggerValue = Number(triggerValue);
    }
    level.triggers[selections.ttarget1][selections.ttarget2][editorStates.x + editorStates.triggerPosition] = [triggerValue, Number(tlength.value), Number(toffset.value)]; //i hope this is all cloned
    //also close the trigger menu
    document.getElementById("tvalue").style.display = "none";
    document.getElementById(`tvalue-${typeMap[selections.ttarget2]}`).style.display = "none"; //breaks if you change the target2 while the menu is open
}

var tableElement = document.getElementById("chartable").appendChild(document.createElement("table"));
tableElement.id = "cttable";
for (let i = 0; i < 4; i++){
    var currentRow = tableElement.appendChild(document.createElement("tr"));
    for (let j = 0; j < 32; j++){
        var currentElementContainer = currentRow.appendChild(document.createElement("td"));
        var currentElement = currentElementContainer.appendChild(document.createElement("span"));
        var currentElementSpacer = currentElementContainer.appendChild(document.createElement("span"));
        currentElementSpacer.textContent = "\xa0";
        currentElement.classList.add("gametile");
        currentElement.id = `ct${i}x${j}`;
        currentElement.addEventListener("click", () => navigator.clipboard.writeText(String.fromCodePoint(chartablePage*128 + i*32 + j)))
    } 
}
var deadlyTiles = ["A", "V", "Ж"];
var solidTiles = ["#", "Z", "Ш"];
var semisolidTiles = ["T"];
var specialTiles = ["@", "Ö", "¤", "÷", "-", "=", "~", "Q", ")", "[", "0", "1", "2", "3", "4", "D", "H", "X", "O", ">", "M", "U", "Đ", "ß", "&"];
var speedchangeTiles = ["0", "1", "2", "3", "4"];
function buildChartable(page){
    document.getElementById("ctrange").textContent = `${(page*128).toString(16)}-${(page*128 + 127).toString(16)}`
    for (let i = 0; i < 4; i++){
        for (let j = 0; j < 32; j++){
            var currentElement = document.getElementById(`ct${i}x${j}`);
            var char = String.fromCodePoint(page*128 + i*32 + j);
            currentElement.textContent = char;
            currentElement.style.backgroundColor = "transparent";
            if (deadlyTiles.includes(char)){
                currentElement.style.backgroundColor = "#FF6060";
            }
            if (solidTiles.includes(char)){
                currentElement.style.backgroundColor = "#B0B0B0";
            }
            if (semisolidTiles.includes(char)){
                currentElement.style.backgroundColor = "#A0A0F0";
            }
            if (specialTiles.includes(char)){
                currentElement.style.backgroundColor = "#00FFFF";
            }
        } 
    } 
}
var chartablePage = 0;
buildChartable(0);
var savingCustom = false;
var savingFromSelection = false;
var shownPreview = -1;
for (let i = 0; i < 2; i++){
    var r = document.getElementById("savedobjs").appendChild(document.createElement("tr"));
    for (let j = 0; j < 8; j++){
        var c = r.appendChild(document.createElement("td"));
        c.textContent = String.fromCodePoint(65 + j + 8*i); //uppercase letters
        c.addEventListener("click", () => {
            if (!savingCustom){
                editorStates.whatToAdd = savefile.savedObjects[j + 8*i];
            }
            else if (savingFromSelection){
                savefile.savedObjects[j + 8*i] = editorStates.selectedTiles;
                savingCustom = false;
            }
            else {
                savefile.savedObjects[j + 8*i] = editorStates.whatToAdd;
                savingCustom = false;
            }
            document.getElementById("saveobj").textContent = "Save object";
            document.getElementById("savesel").textContent = "Save selection";
        });
        c.addEventListener("mouseenter", () => {
            //create tiles
            shownPreview = j + 8*i;
            var instring = "";
            let n = 0;
            let k = 0;
            if (!savefile.savedObjects[j + 8*i]) {return;}
            for (var u of savefile.savedObjects[j + 8*i]){
                k = 0;
                for (var v of u){
                    var w = stateAt(v, currentRenderer/10); //currentrenderer stores the timestamb generated by th eanimation frame of th erender function so it functions as a global timer, division is due to units 
                    if (w && w.behavior == "default"){
                        w.behavior = "none";
                        if (solidTiles.includes(w.char)){w.behavior = "solid"}
                        if (semisolidTiles.includes(w.char)){w.behavior = "semisolid"}
                        if (deadlyTiles.includes(w.char)){w.behavior = "kill"}
                        if (specialTiles.includes(w.char)){w.behavior = "default"}
                    }
                    instring += (w && v && exists(v)) ? `<span id="pre${n}x${k}" display="block" style="color: ${previewmode.checked ? noprevColors[w.colorGroup] : typeprevColors[w.behavior]}">${w.char}</span>` : `<span id="pre${n}x${k}">&nbsp;</span>`;
                    k++;
                }
                instring += "<br>"
                n++;
            }
            document.getElementById("savedobjpreview").innerHTML = instring;
            document.getElementById("savedobjpreview").style.display = "block";
        });
        c.addEventListener("mouseleave", () => {
            document.getElementById("savedobjpreview").style.display = "none";
            shownPreview = -1;
        });
    }
}
var noprevColors = [null, "rgb(255 0 0)", "rgb(255 156 0)", "rgb(255 255 0)", "rgb(131 255 0)", "rgb(0 255 131)", "rgb(0 190 255)", "rgb(0 0 255)", "rgb(187 0 255)", "rgb(255 0 212)"];
var typeprevColors = {
    solid: "rgb(0 0 0)",
    semisolid: "rgb(64 64 128)",
    kill: "rgb(255 0 0)",
    special: "rgb(0 255 255)",
    none: "rgb(220 220 220)",
};
///////////////////////////////
//         load data         //
///////////////////////////////

const levelLoader = new XMLHttpRequest(); //fuck promises
function loadLevel(name){
    levelLoader.open("GET", `http://azertite055.github.io/maps/${name}`); //hardcoded url lol
    levelLoader.responseType = "blob";
    levelLoader.send();
} //in the release version this will run at startup
levelLoader.onloadend = (e) => {
    importLevel(levelLoader.response, level);
};
/* load main levels -- uncomment in final (IF I HAD ANY)
for (let i = 0; i < 5; i++){
    loadLevel(`map${i}`);
    mainLevels.push(structuredClone(level));
}
*/
function loadSavefile(data){
    savefile = structuredClone(data);
    //setup toggles to make sense
    setautoretry.checked = savefile.settings.autoRetry;
    setdispsize.checked = savefile.settings.gameSize;
    setshowatts.checked = savefile.settings.showAttempts;
    setshowperc.checked = savefile.settings.showPrecentage;
    level = structuredClone(savefile.maps[Number(levelID)]);
    if (level.startPosData){
        document.getElementById("startpospart1").textContent = "Remove start position";
    }
}
if (localStorage.getItem("newtextdashsave")){
    loadSavefile(JSON.parse(localStorage.getItem("newtextdashsave")));
}
///////////////////////////////
//      handling stuff       //
///////////////////////////////
function handleStartposSetter(){
    if (level.startPosData){
        level.startPosData = false;
        document.getElementById("startpospart1").textContent = "Set start position";
    }
    else {
        editorStates.mode="startpos";
        document.getElementById("startpospart1").textContent = "Select position on editor";
    }
}
function tileHoverHandler(x, y, press){ //x and y are display coords, press is true when this is called from a click (false when called from hover)
    y += editorStates.x;
    if (currentTab == "edit" && (isMouseDown || press)){
        switch (editorStates.mode) {
            case "add":
                if (deletemode.checked) {
                    level.tiles[x][y] = null;
                    if (level.speedChanges.map(a => a[0]).indexOf(y) != -1 && level.speedChanges[level.speedChanges.map(a => a[0]).indexOf(y)][2] == x){ //remove (overwrite) speed changes
                        level.speedChanges = removeNthElement(level.speedChanges, level.speedChanges.map(a => a[0]).indexOf(y));
                    }
                    if (y == level.tiles[0].length-1){ //shorten editor only if we remove the last tile
                        let q = true;
                        let w = y;
                        while (q && w>=gameWidth){
                            q = true;
                            for (let i=0; i<10; i++){
                                q &&= !exists(level.tiles[i][w]);
                            }
                            if(q){w--}
                        }
                        changeEditorLength(w+1);
                    }
                } 
                else {
                    addTiles(x, y);
                }
                break;
            case "select":
                if (press){
                    selectTiles(x, y);
                }
                break;
            case "startpos":
                document.getElementById("startpospart1").textContent = "Remove start position";
                editorStates.mode = "add";
                level.startPosData = [{
                    y: 0,
                    mode: 0, gravity: -1,
                    bufferCheck: true, previousTile: false,
                    dashing: false, fallTimer: 4, var1: 0,
                    jumpTimer: 0, jumpFrames: 0, hoverFrames: 0,
                },null,{
                    x: 0, speed: 1, xSub: 0, frame: 0,
                    P2Active: false,
                }];
                level.startPosData[0].y = x;
                level.startPosData[0].mode = Number(prompt("Enter gamemode number (refer to editor guide)"));
                level.startPosData[0].gravity = Number(prompt("Enter gravity value (1 or -1)"));
                level.startPosData[1] = structuredClone(level.startPosData[0]);
                level.startPosData[2].x = y;
                level.startPosData[2].speed = Number(prompt("Enter speed value (0~4)"));
                break;
        }
    }
}

var pressedKeys = [];
var heldKeys = [];
var releasedKeys = [];
document.addEventListener("keydown", function(e){
    pressedKeys.push(e.key); //cleared on every logic frame
    heldKeys.push(e.key);
});
document.addEventListener("keyup", function(e){
    releasedKeys.push(e.key); //cleared on every logic frame
    heldKeys = heldKeys.filter(x => x != e.key); //removes the key in question from the array
});

var isMouseDown = false;
var mousePressed = false;
var mouseReleased = false;
document.addEventListener("mousedown", function(e){
    isMouseDown = true;
    mousePressed = true; //cleared on every logic frame
});
document.addEventListener("mouseup", function(e){
    isMouseDown = false;
    mouseReleased = true //cleared on every logic frame
    editorStates.velocity = 0;
});
document.addEventListener("mousemove", function(e){
    document.getElementById("savedobjpreview").style.top = `${e.y}px`;
    document.getElementById("savedobjpreview").style.left = `${e.x}px`;
});
window.addEventListener("beforeunload", (ev) =>{
    if(currentTab=="edit"){savefile.maps[Number(levelID)] = structuredClone(level)};
    localStorage.setItem("newtextdashsave", JSON.stringify(savefile));
});
startupFlag = false;
</script>
</html>
