<!DOCTYPE html>
<head>
    <title>Division Generator</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="container" style="width: 800px; height:30px; outline: black 1px solid;"></div>
    <div>the division list is a comma-seperated list of whole numbers 0,1,2, etc</div>
    <label for="ilist">Division list: </label><input type="text" name="ilist" id="ilist" onchange="updateDisplay()">
    <br>
    <label for="iiters">Iterations: </label><input type="number" name="iiters" id="iiters" onchange="updateDisplay()">
    <br>
    <div>&nbsp;<span id="bigalert" style="color: red; display: none;">Results with a lot of parts are not autocomputed to prevent freezing. Click this button to calculate: <button onclick="updateDisplay(false)">!!!</button></span></div>
    ratio: <span id="dratio"></span>
    <br>
    parts: <span id="dparts"></span>
    <br>
    normlen: <span id="dnormlen"></span>
    <br>
    <button onclick="a = new AudioContext(); playTimestamps(timestamps, Number(isoundlen.value))"> Play sound</button>
    <label for="isoundlen"> Length (s): </label><input type="number" name="isoundlen" id="isoundlen" value="1">
    <br>
    <label for="inotelen"> Note length (s): </label><input type="number" name="inotelen" id="inotelen" value="0.1"> | 
    <label for="inotefreq"> Note frequency (Hz): </label><input type="number" name="inotefreq" id="inotefreq" value="440">
    <br>
    <a id="dllink" href="" download="divgen.wav">Download last played sound</a>
    <br>
    <button onclick="document.getElementById('exportarea').value = divparts.join(',')">Export parts</button>
    <button onclick="document.getElementById('exportarea').value = timestamps.join(',')">Export timestamps</button>
    <br>
    <textarea placeholder="Export data will appear here" id="exportarea"></textarea>
    <br><br><br>
    <h2>What is this?</h2>
    <div>
        Segments are identified with a number, with 0 being the base, and each one after (1,2,...) is a certian ratio times shorter than the last<br>
        The ratio is automatically calculated based on the division list<br>
        Each iteration, the type 0 segments are split into smaller segments according to the division list<br>
        The exact iteration rule is: n&RightArrow;n-1 for nonzero n, and 0&RightArrow;(division list)<br>
        
        Normlen is the normalized length, if we consider a 0 segment as the unit<br>
        The sequences generated have a kind of order but are not periodic in general<br>
        Examples:<br>
        0,0: halving<br>
        0,1: golden ratio / fibonacci<br>
        0,0,1: silver ratio<br>
        0,1,2: tribonacci<br>
        0,2: narayana's cows<br>
    </div>
    <script>
var divparts = [];
var timestamps = [];
function subdivide(x, d){
    return x.flatMap(t => t > 0 ? t-1 : d);
}
function solvePolynoms(a, init){
	var now = init;
	var last = init-1000;
	while (Math.abs(now-last) > 0.0000000001){
		last = now;
		now -= evaluatePolynoms(a, now) / evaluatePolynoms(derivativePolynoms(a), now); //newton's method
	}
	return now;
}
function evaluatePolynoms(a, point){
	return a.reduce((x, y, z) => x + y*(point**z), 0)
}
function derivativePolynoms(a){
	var b = a.map((x, y) => x * y);
	b.shift();
	return b;
}
//this accidentally finds the reciprocal of the root but whatever we needed that anyway
function findRatio(d){
    var s = Array(100).fill(0);
    for (let i of d){
        s[i]--;
    }
    s.unshift(1)
    return solvePolynoms(s, 2);
} 
function getTimestamps(d, iter){
    var list = [0];
    for (let i = 0; i < iter; i++){
        list = subdivide(list, d);
    }
    divparts = list;
    var timelist = Array(list.length).fill(0);
    var r = findRatio(d);
    for (let i = 0; i < timelist.length-1; i++){
        timelist[i+1] = timelist[i] + r**list[i];
    }
    timelist = timelist.map(x => x*r**iter);
    timestamps = timelist;
}

var c = document.createElement("canvas");
c.width = 800;
c.height = 30;
document.getElementById("container").appendChild(c);
var cd = c.getContext("2d");
function draw(a){
    cd.reset();
    cd.fillStyle = "black"
    if (a.length < 10000){
        for (let x of a){
            cd.fillRect(x*800, 0, Math.min(1, 1000/a.length), 30);
        }
    }
    else {
        for (let i = 0; i < 10000; i++){
            cd.fillRect(a[Math.floor(i*a.length/10000)]*800, 0, 0.1, 30);
        }
    }
}
function updateDisplay(limited = true){
    document.getElementById("bigalert").style.display = "none";
    var d = ilist.value.split(",").map(x => Number(x));
    var iter = Number(iiters.value);
    var r = findRatio(d);
    if (r**-iter > 1e6 && limited){
        document.getElementById("bigalert").style.display = "inline";
        return;
    }
    getTimestamps(d, iter);
    draw(timestamps);
    document.getElementById("dratio").textContent = 1/r;
    document.getElementById("dparts").textContent = timestamps.length;
    document.getElementById("dnormlen").textContent = 1/r**iter;
}
var a = new AudioContext();

function intoBytes(x, nBytes, bigEndian){
    var out = Array(nBytes).fill(0);
    for (i = 0; i < nBytes; i++){
        out[i] = Math.min(x - (2**8)*(x>>8), 255);
        x >>= 8;
    }
    if (bigEndian) {out.reverse()}
    return out;
}
function signedIntRep(x, bytes){
    if (x < 0) {x += 2}
    x = Math.ceil(x * 2**(8*bytes - 1)) - 1;
    return x;
}
function writeToWav(dataL, dataR, sampleRate, bytesPerSample){
    var dataSize = dataL.length * bytesPerSample * 2; //2 channels!
    var out = new Uint8Array(dataSize+44);
    out.set([ 82, 73, 70, 70 ], 0); //"RIFF"
    out.set(intoBytes(dataSize+44, 4, false), 4); //file size
    out.set([ 87, 65, 86, 69], 8); //"WAVE"
    out.set([102, 109, 116, 32], 12); //"fmt "
    out.set([16, 0, 0, 0], 16); //format data length
    out.set([1, 0], 20); //format identifier
    out.set([2, 0], 22); //channels
    out.set(intoBytes(sampleRate, 4, false), 24); //sample rate
    out.set(intoBytes(sampleRate*bytesPerSample*2, 4, false), 28); //bytes per second
    out.set(intoBytes(bytesPerSample*2, 2, false), 32); //total bytes per sample (2 channels)
    out.set(intoBytes(bytesPerSample*8, 2, false), 34); //bits per sample
    out.set([ 100, 97, 116, 97 ], 36); //"data"
    out.set(intoBytes(dataSize, 4, false), 40); //data size

    dataL = dataL.map(x => signedIntRep(x, bytesPerSample)); //map datas into range
    dataR = dataR.map(x => signedIntRep(x, bytesPerSample));

    var writeOffset = 44;
    for (let i = 0; i < dataL.length; i++){
        out.set(intoBytes(dataL[i], bytesPerSample, false), writeOffset);
        writeOffset += bytesPerSample;
        out.set(intoBytes(dataR[i], bytesPerSample, false), writeOffset);
        writeOffset += bytesPerSample;
    }
    return out;
}

var dlurl = "sorry nothing";
function playTimestamps(timeData, t, dl=false){
    //get values
    var notelen = Number(inotelen.value);
    var notefreq = Number(inotefreq.value);

    //create stroage
    var notedata = Array(a.sampleRate*notelen).fill(0);
    notedata = notedata.map((x, i) => Math.cos(i * (2*Math.PI) * notefreq / a.sampleRate) * (notedata.length-i)/notedata.length);
    var baseSize = Math.ceil(a.sampleRate*t)
    var totalSize = baseSize + notedata.length;
    var s = new AudioBuffer({
        length: totalSize,
        sampleRate: a.sampleRate,
    });
    //generate notes
    var sdata = Array(totalSize).fill(0);
    for (let x of timeData){
        var pos = Math.floor(x*baseSize);
        for (let i = 0; i < notedata.length; i++){
            sdata[pos+i] += notedata[i];
        }
    }
    //normalize wave
    var highest = Math.max(...(sdata.map(x => Math.abs(x))));
    sdata = sdata.map(x => x/highest);

    console.log(sdata);

    //set up downloader
    URL.revokeObjectURL(dlurl);
    var wavdata = writeToWav(sdata, sdata, a.sampleRate, 2);
    console.log(wavdata);
    var dldata = new Blob([wavdata], {type: "audio/wav"});
    dlurl = URL.createObjectURL(dldata);
    document.getElementById("dllink").href = dlurl;

    //set up playing audio
    var chdata = s.getChannelData(0);
    for (let i = 0; i < sdata.length; i++){
        chdata[i] = sdata[i]; 
    }
    var snode = new AudioBufferSourceNode(a, {buffer: s});
    snode.connect(a.destination);
    snode.start(a.currentTime, 0, t);
}
    </script>
</body>
